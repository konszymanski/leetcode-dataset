import re

class Node(object):
    def evaluate(self):
        pass
    
class Operand(Node):
    def __init__(self,val):
        self.val = int(val)
        
    def evaluate(self):
        return self.val
        
class Operator(Node):
    def __init__(self,op,l=None,r=None):
        self.l = l
        self.r = r
        self.op = op
        
    def evaluate(self):
        if   self.op == "*":
            return self.l.evaluate() * self.r.evaluate()
        elif self.op == "+":
            return self.l.evaluate() + self.r.evaluate()
        elif self.op == "/":
            return self.l.evaluate() // self.r.evaluate()
        elif self.op == "-":
            return self.l.evaluate() - self.r.evaluate()
        else:
            raise ValueError("Illegal Operator")

class Solution(object):
    def calculate(self, s):

        oP = {"*" : 1,"/" : 1, "+" : 0, "-" : 0}
        
        tokens = re.findall(\'\\d+|\\S\', s)
        
        root = self.buildTree(tokens,oP)
        
        return root.evaluate()
    
    def buildTree(self,tokens,oP):
        
        lpi = self.findLPop(tokens,oP)
        
        # If no operators, we must only have one token, and it must be an Operand
        if lpi < 0:
            return Operand(tokens[0])
        
        leftTree = self.buildTree(tokens[:lpi],oP)
        rightTree = self.buildTree(tokens[lpi+1:],oP)
        
        return Operator(tokens[lpi],leftTree,rightTree)
        
        
    def findLPop(self,tokens,oP):
        lp = 2
        j = -1
        for i,c in enumerate(tokens):
            if c in oP and oP[c] <= lp:
                lp = oP[c]
                j = i
            
        return j