"""
Implementation based on LR(0)

# Grammar
E\'-> E    (1)
E -> E+T  (2)
E -> E-T  (3)
E -> T    (4)
T -> T*N  (5)
T -> T/N  (6)
T -> N    (7)

# First | Follow
   | First | Follow
-  |   -   |   -
E\' |   N   |   $
E  |   N   | $,+,-
T  |   N   | $,*,/,+,-

# DFA

           N      +---S12---+ <--------------------------+
      +---------> | T -> N. | <-----------+      N       |
      |           +---------+       N     |              |
      |                                   |              |
+----S1-----+     +----S2-----+         + |         +----S4-----+  T   +-----S6----+
| E\'-> .E   | E   | E\'-> E.   |-----------|-------> | E -> E+.T | ---> | E -> E+T. | -+
| E -> .E+T |---> | E -> E.+T | -   +----S5-----+   | T -> .T*N |      | T -> T.*N |  |
| E -> .E-T |     | E -> E.-T |---> | E -> E-.T |   | T -> .T/N |      | T -> T./N | ---+
| E -> .T   |     +-----------+     | T -> .T*N |   | T -> .N   |      +-----------+  | |
| T -> .T*N |     +----S3-----+     | T -> .T/N |   +-----------+  T   +-----S7----+  | |
| T -> .T/N | T   | E -> T.   |     | T -> .N   | -------------------> | E -> E-T. |  | |
| T -> .N   |---> | T -> T.*N |     +-----------+                      | T -> T.*N |  | |
+-----------+     | T -> T./N |                                        | T -> T./N |  | |
                  +-----------+                                        +-----------+  | |
                     |     |   *                   +----S8-----+      *    |   |      | |
                     |     +---------------------> | T -> T*.N | <---------+ * |      | |
                     |                             +-----------+ <-------------|------+ |
                     |      /       +----S9-----+        |       /             |        |
                     +------------> | T -> T/.N | <------|---------------------+        |
                                    +-----------+ <------|------------------------------+
                                        N \u2193            N \u2193       /
                                    +----S11----+ +----S10----+
                                    | T -> T/N. | | T -> T*N. |
                                    +-----------+ +-----------+
# Parsing Table
+--------+-----------------------------------------------------+-----------------+
|        |                       ACTION                        |       GOTO      |
| STATE  +--------+--------+--------+--------+--------+--------+--------+--------+
|        |    N   |    +   |    -   |    *   |    /   |    $   |    E   |    T   |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
|   1    |   s12  |        |        |        |        |        |    2   |    3   |
|   2    |        |   s4   |   s5   |        |        | r1(acc)|        |        |
|   3    |   r4   |   r4   |   r4   |   s8   |   s9   |   r4   |        |        |
|   4    |   s12  |        |        |        |        |        |        |    6   |
|   5    |   s12  |        |        |        |        |        |        |    7   |
|   6    |   r2   |   r2   |   r2   |   s8   |   s9   |   r2   |        |        |
|   7    |   r3   |   r3   |   r3   |   s8   |   s9   |   r3   |        |        |
|   8    |   s10  |        |        |        |        |        |        |        |
|   9    |   s11  |        |        |        |        |        |        |        |
|   10   |   r5   |   r5   |   r5   |   r5   |   r5   |   r5   |        |        |
|   11   |   r6   |   r6   |   r6   |   r6   |   r6   |   r6   |        |        |
|   12   |   r7   |   r7   |   r7   |   r7   |   r7   |   r7   |        |        |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+

# Example
+------+--------------+-------------+----------------+----------------------+
|      |    STACK     |   SYMBOLS   |     INPUT      |        ACTION        |
+------+--------------+-------------+----------------+----------------------+
|  (1) | 1            |             | 14 - 24 / 12 $ | shift                |
|  (2) | 1 12         |  N          |    - 24 / 12 $ | reduce by T -> N     |
|  (3) | 1 3          |  T          |    - 24 / id $ | reduce by E -> T     |
|  (4) | 1 2          |  E          |    - 24 / 12 $ | shift                |
|  (4) | 1 2 5        |  E -        |      24 / 12 $ | shift                |
|  (5) | 1 2 5 12     |  E - N      |         / 12 $ | reduce by T -> N     |
|  (6) | 1 2 5 7      |  E - T      |         / 12 $ | shift                |
|  (7) | 1 2 5 7 9    |  E - T /    |           12 $ | shift                |
|  (8) | 1 2 5 7 9 11 |  E - T / N  |              $ | reduce by T -> T / N |
|  (9) | 1 2 5 7      |  E - T      |              $ | reduce by E -> E - T |
| (10) | 1 2          |  E          |              $ | accept               |
+------+--------------+-------------+----------------+----------------------+
"""
# (number of popped symb, derived symb)
reduce_rules = {
    1: (0, \'Done\'),
    2: (3, \'E\'),
    3: (3, \'E\'),
    4: (1, \'E\'),
    5: (3, \'T\'),
    6: (3, \'T\'),
    7: (1, \'T\')
}

# negative => reduce / positive => shift
parsing_table = {
    1: {\'N\': 12, \'E\': 2, \'T\': 3},
    2: {\'+\': 4, \'-\': 5, \'$\': -1},
    3: {\'+\': -4, \'-\': -4, \'$\': -4, \'*\': 8, \'/\': 9, \'N\': -4},
    4: {\'N\': 12, \'T\': 6},
    5: {\'N\': 12, \'T\': 7},
    6: {\'+\': -2, \'-\': -2, \'$\': -2, \'*\': 8, \'/\': 9, \'N\': -2},
    7: {\'+\': -3, \'-\': -3, \'$\': -3, \'*\': 8, \'/\': 9, \'N\': -3},
    8: {\'N\': 10},
    9: {\'N\': 11},
    10:{\'+\': -5, \'-\': -5, \'$\': -5, \'*\': -5, \'/\': -5, \'N\': -5},
    11:{\'+\': -6, \'-\': -6, \'$\': -6, \'*\': -6, \'/\': -6, \'N\': -6},
    12:{\'+\': -7, \'-\': -7, \'$\': -7, \'*\': -7, \'/\': -7, \'N\': -7},
}

class ParserLR0:
    def __init__(self, E: str) -> None:
        self.E = E
        self.pos = 0
        self.states = [1]  # set initial state to 1
        self.symbs = []
        
    def symb2key(self, symb: str) -> str:
        # raw symb can only be either \'+-*/\' or \'N\'
        return symb if symb in [\'$\', \'+\', \'-\', \'*\', \'/\'] else \'N\'

    def parse(self):
        while True:
            symb = self.E[self.pos]
            nxt_state = parsing_table[self.states[-1]][self.symb2key(symb)]
            if nxt_state > 0:
                # shift
                self.states.append(nxt_state)
                self.symbs.append(symb)
                self.pos += 1
            else:
                # reduce
                pop_n, derived_symb = reduce_rules[-nxt_state]
                if pop_n == 0:
                    # assume all input is valid, symbs will leave the answer
                    return self.symbs[0]
                else:
                    if pop_n == 1:  # simple reduction
                        # reduce states
                        self.states.pop()
                        self.states.append(parsing_table[self.states[-1]][derived_symb])
                        # derivation
                        # Since reduce from T -> N and E -> T don\'t change the symbol value
                        # namely, self.symbs.append(self.symbs.pop()) == pass
                    elif pop_n == 3:  # operator reduction
                        # reduce states
                        self.states = self.states[:-2]  # pop 2 states
                        # derivation: get lval, operator, and rval => calculate the result
                        lval, operator, rval = self.symbs[-3:]
                        self.symbs = self.symbs[:-3]  # pop 3 symbols
                        if operator == \'+\':
                            self.symbs.append(lval + rval)
                        elif operator == \'-\':
                            self.symbs.append(lval - rval)
                        elif operator == \'*\':
                            self.symbs.append(lval * rval)
                        elif operator == \'/\':
                            self.symbs.append(lval // rval)


class Solution:    
    def lexer(self, s: str) -> List[str]:
        symbs, idx = [], 0
        while idx < len(s):
            if s[idx] in \'+-*/\':
                symbs.append(s[idx])
                idx += 1
            elif s[idx] in \'1234567890\':
                num_pat = s[idx]
                idx += 1
                while idx < len(s) and s[idx] in \'1234567890\':
                    num_pat += s[idx]
                    idx += 1
                symbs.append(int(num_pat))
            else:
                idx += 1
        symbs.append(\'$\')
        return symbs
    
    def calculate(self, s: str) -> int:
        return ParserLR0(self.lexer(s)).parse()