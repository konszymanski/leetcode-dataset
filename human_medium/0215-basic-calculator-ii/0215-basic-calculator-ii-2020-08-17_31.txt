class Parser:
    def __init__(self, tokens):
        """grouping has highest precedence, then */, and then +-
        
        evaluating the expression after parsing since input is always valid
        """
        self.tokens = tokens
        self.current = 0
    
    def parse(self):
        """start -> expression
        """
        return self.expression()
    
    def expression(self):
        """expression -> addition
        """
        return self.addition()
        
    def addition(self):
        """addition -> multiplication ( ( \'+\' | \'-\') multiplication )*
        """
        expr = self.multiplication()
        while self.peek(\'+\', \'-\'):
            operator = self.advance()
            right = self.multiplication()
            expr = expr + right if operator == "+" else expr - right
        return expr
    
    def multiplication(self):
        """multiplication -> unary ( ( \'*\' | \'/\' ) unary )*
        """
        expr = self.unary()
        while self.peek(\'*\', \'/\'):
            operator = self.advance()
            right = self.unary()
            expr = expr * right if operator == "*" else expr // right
        return expr
    
    def unary(self):
        """unary -> int | \'(\' expression \')\'
        """
        if self.peek(\'(\'):  # grouping
            self.advance()  # consume (
            expr = self.expression()
            self.advance()  # consume )
            return expr
        return int(self.advance())
    
    def peek(self, *args):
        if self.current >= len(self.tokens):
            return False
        for arg in args:
            if self.tokens[self.current] == arg:
                return True
        return False

    def advance(self):
        self.current += 1
        return self.tokens[self.current - 1]
        
class Solution:
    
    @staticmethod
    def lexer(source):
        idx = 0
        ignore = set(string.whitespace)
        tokens = []
        while idx < len(source):
            ch = source[idx]
            if ch in ignore:
                idx += 1
            elif ch.isdigit():
                num = ch
                idx += 1
                while idx < len(source) and source[idx].isdigit():
                    num += source[idx]
                    idx += 1
                tokens.append(num)
            else:
                idx += 1
                tokens.append(ch)
        return tokens

    def calculate(self, s: str) -> int:
        return Parser(self.lexer(s)).parse()