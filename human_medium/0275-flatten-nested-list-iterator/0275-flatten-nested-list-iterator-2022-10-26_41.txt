class NestedIterator:
    def flatten(self, nlist):
        res =[]
        for i in nlist:
            if i.isInteger():
                res.append(i.getInteger())
            else:
                res += self.flatten(i.getList())
        return res 
    
    def __init__(self, nestedList: [NestedInteger]):
        self.cache = []
        self.c_it = 0
        self.g_it = 0
        self.nestedList = nestedList
        self.g_len = len(self.nestedList)
        self.peek = None
        
        
    def get_next(self):
        if self.c_it < len(self.cache):
            item = self.cache[self.c_it]
            self.c_it += 1
            return item
        elif self.g_it < self.g_len:
            if self.nestedList[self.g_it].isInteger():
                item = self.nestedList[self.g_it].getInteger()
                self.g_it += 1
                return item
            else:
                self.cache = self.flatten(self.nestedList[self.g_it].getList())
                self.g_it += 1
                if len(self.cache) > 0:
                    self.c_it = 1
                    return self.cache[0] 
                else:
                    if self.g_it < self.g_len:
                        return self.get_next()
    def next(self) -> int:
        next_integer = self.peek
        self.peek = None
        return next_integer
    
    def hasNext(self) -> bool:
        if self.peek is not None:
            return True
        else:
            self.peek = self.get_next()
        return self.peek is not None