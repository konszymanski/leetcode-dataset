class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.queue = collections.deque([]) # list like container with fast pops and appends on both ends
        self.dfs(nestedList)            # function flattens nested list
    def dfs(self, nest):        
        for x in nest:                  # iterates nested list
            if x.isInteger():           # if list is integer, append it to queue 
                self.queue.append(x.getInteger())
            else:
                self.dfs(x.getList())   # else call dfs again with nested list
    def next(self) -> int:
        return self.queue.popleft()     # remove element from left side of queue and return it
    def hasNext(self) -> bool:
        return len(self.queue) > 0       # returns bool : queue length is greater than 0 ?