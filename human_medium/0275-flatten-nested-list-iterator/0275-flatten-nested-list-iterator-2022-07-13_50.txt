class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):        
        def flatten(nest) -> int:
            for n in nest:
                if n.isInteger():
                    yield n.getInteger()
                    continue
                yield from flatten(n.getList())
        # calling the function here is what returns the generator, which is
		# what we call next() on later.  this is known as "priming".
        self.gen = flatten(nestedList)
        
    def next(self) -> int:
        return self.next_val
    
    def hasNext(self) -> bool:
		# when the generator runs out of values it will return None
        self.next_val = next(self.gen, None)
        return self.next_val is not None