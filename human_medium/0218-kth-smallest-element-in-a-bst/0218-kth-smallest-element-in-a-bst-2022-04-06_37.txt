# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

# inorder traversal would give us sorted nodes
# then it is enough to decrement k at each node until k is 0

# Follow up
# it could be optimized if we had a field that describes an ordering
# of a node in a tree:

# class TreeNode:
#     def __init__(self, val=0, order=0, left=None, right=None):
#         self.val = val
#         self.order = order  
#         self.left = left
#         self.right = right

# then, we would just check if node.order == k-1 and if it is, return it.
class Solution:
    # recursive
    # def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
    #     def inorder(r):
    #         return inorder(r.left) + [r.val] + inorder(r.right) if r else []
    #     return inorder(root)[k-1]
    
    # iterative
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        stack = []
        while True:
            while root:
                # stacking leftmost nodes
                # inorder(r.left) for recursive
                stack.append(root)
                root = root.left
            # starting from the leftmost node
            # r.val in recursive
            root = stack.pop()
            k -= 1
            if not k:
                return root.val
            # inorder r.right in recursive
            root = root.right