class Solution: # top down + memoization
    def canPartition(self, nums: List[int]) -> bool:
        target = sum(nums)
        
        if target % 2: return False # sum must be even number to divide it nums into 2 parts
        
        target //= 2
        
        @cache
        def dfs(target, i):
            if target == 0: return True
            if target < 0: return False
            if i == len(nums): return False
            
            op1 = dfs(target - nums[i], i + 1)
            if op1: return True
            return dfs(target, i + 1)
        
        return dfs(target, 0)

class Solution: # bottom up using tabulation
    def canPartition(self, nums: List[int]) -> bool:
        target = sum(nums)
        
        if target % 2: return False # sum must be even number to divide it nums into 2 parts
        
        target //= 2
        dp = [[False] * (target + 1) for _ in range(len(nums) + 1)]
        
        for r in range(len(nums) + 1):
            dp[r][0] = True # any array can form a target sum of 0
        
        for r in range(1, len(dp)):
            for c in range(1, len(dp[0])):
                t = c
                val = nums[r - 1]
                
                if t - val >= 0:
                    dp[r][c] = dp[r - 1][t - val]
                
                dp[r][c] = dp[r][c] or dp[r - 1][c]
                
                if t == target and dp[r][c]: return True
                
        return False