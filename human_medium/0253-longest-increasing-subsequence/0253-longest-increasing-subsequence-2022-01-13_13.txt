def lengthOfLIS(self, nums: List[int]) -> int:
        
        # helper
        def f(i, prevIndx):
            if i == len(nums):
                return 0

            if (i, prevIndx) in memo:
                return memo[(i, prevIndx)]
            
            c1 = 0
            if prevIndx == -1 or nums[i] > nums[prevIndx]: # inclusion is conditional - only if cur > prev
                c1 = 1 + f(i+1, i)

            c2 = f(i+1, prevIndx) # exclusion is a must always - see comment below
            memo[(i, prevIndx)] = max(c1, c2)

            return memo[(i, prevIndx)]

        # main
        memo = {}
        return f(0, -1)

		# -- comment [1]
        \'\'\'
        skipping allows us to consider nums at the start with nums that come later even though
        there might be a huge gap in between
        
        consider
        
        [4, 1, 2, 3, 8, 5 .... ]
        -> 1,2,3,8 is longest
        
        but if we keep going
        [4, 1, 2, 3, 8, 5, 9, 10, 12, 133 ]
        we see that 4,8,9,10,12,133 is longest
        
        so we need to not give up on the 4 cuz we don\'t know what the future holds for us
        \'\'\'