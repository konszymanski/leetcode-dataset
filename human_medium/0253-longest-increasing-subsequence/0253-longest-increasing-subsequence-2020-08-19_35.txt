class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        
        """
        DP Solution
        """
        # lets first implement DP
        if not nums: return 0
        dp = [1] * len(nums)
        
        maxNum = 1
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i],1+dp[j])
                    if dp[i] > maxNum: maxNum = dp[i]          
        
        return maxNum
        
        """
        BS Solution
        This solution is known as patience sorting
        - idea is visualize a set of numbered cards being fed one at a time
        - list (T) will first take the number and add to stack
        - For the following numbers the following are considered:
            - if the number is lower than the first value in arr, replace the number with current
            - if number is greater than the last item (number), append the number to end of list
            - if currNumber is greater than first item but smaller than second item, we need to find the position where 
                the value is greater than previous position but smaller than the current position being considered using Binary Search!
        - The length of arr T will show us the longest subsequence.
        
        """
        if not nums: return 0
        
        def binarySearch(num,arr):
            # find the point where number is greater than current and less than next position
            l = 0
            r = len(arr)
            
            while l <= r:
                mid = (l+r) // 2
                if T[mid] == num:
                    return mid
                elif mid < len(T) and T[mid] < num and T[mid+1] >= num:
                    return mid+1
                elif T[mid] > num:
                    r = mid-1
                else:
                    l = mid+1
            return -1
        T = [nums[0]]
        currLen = 0
        for i in range(1,len(nums)):
            if nums[i] <= T[0]:
                T[0] = nums[i]
            elif nums[i] > T[len(T)-1]:
                T.append(nums[i])
            else:
                # Binary Search and add somewhere in between
                index = binarySearch(nums[i],T)
                T[index] = nums[i]
        return len(T)