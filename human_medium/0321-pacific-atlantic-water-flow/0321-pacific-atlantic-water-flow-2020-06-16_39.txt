\'\'\'
M1: DFS Mine
\'\'\'
class Solution:
    def pacificAtlantic(self, matrix):
        if not matrix: return
        m, n = len(matrix), len(matrix[0])
        def dfs(i, j, visited):
            if (i, j) in visited:
                return
            visited.add((i,j))
            if j-1>=0 and matrix[i][j]<=matrix[i][j-1]:
                dfs(i, j-1, visited)
            if i-1>=0 and matrix[i][j]<=matrix[i-1][j]:
                dfs(i-1, j, visited)
            if j+1<n and matrix[i][j]<=matrix[i][j+1]:
                dfs(i, j+1, visited)
            if i+1<m and matrix[i][j]<=matrix[i+1][j]:
                dfs(i+1, j, visited)
        
        pacific_points = [(0, j) for j in range(n)] + [(i, 0) for i in range(m)]
        atlantic_points = [(m-1, j) for j in range(n)] + [(i, n-1) for i in range(m)]
        
        pacific_visited, atlantic_visited = set(), set()

        for i, j in pacific_points: dfs(i, j, pacific_visited)
        for i, j in atlantic_points: dfs(i, j, atlantic_visited)
        
        return pacific_visited & atlantic_visited

\'\'\'
or using directions
\'\'\'
class Solution:
    def pacificAtlantic(self, matrix):
        if not matrix: return
        m, n, directions = len(matrix), len(matrix[0]), [(0,-1), (-1,0), (0, 1), (1, 0)]
        def dfs(i, j, visited):
            if (i, j) in visited: return
            visited.add((i,j))
            for d in directions:
                next_i, next_j = i+d[0], j+d[1]
                if next_i>=0 and next_i<m and next_j>=0 and next_j<n and matrix[i][j]<=matrix[next_i][next_j]:
                    dfs(next_i, next_j, visited)
        pacific_points, pacific_visited = [(0, j) for j in range(n)] + [(i, 0) for i in range(m)], set()
        atlantic_points, atlantic_visited = [(m-1, j) for j in range(n)] + [(i, n-1) for i in range(m)], set()
        for i, j in pacific_points: dfs(i, j, pacific_visited)
        for i, j in atlantic_points: dfs(i, j, atlantic_visited)
        return pacific_visited & atlantic_visited

\'\'\'
M2: BFS
\'\'\'
from collections import deque
class Solution:
    def pacificAtlantic(self, matrix):
        if not matrix: return
        m, n, directions = len(matrix), len(matrix[0]), [(0,-1), (-1,0), (0, 1), (1, 0)]
        def bfs(points, visited):
            while points:
                i, j = points.popleft()
                if (i, j) in visited: continue
                visited.add((i, j))
                for d in directions:
                    next_i, next_j = i+d[0], j+d[1]
                    if (next_i, next_j) not in visited and next_i>=0 and next_i<m and next_j>=0 and next_j<n and matrix[i][j]<=matrix[next_i][next_j]:
                        points.append((next_i, next_j)) 
        pacific_points, pacific_visited = deque([(0, j) for j in range(n)] + [(i, 0) for i in range(m)]), set()
        atlantic_points, atlantic_visited = deque([(m-1, j) for j in range(n)] + [(i, n-1) for i in range(m)]), set()
        bfs(pacific_points, pacific_visited)
        bfs(atlantic_points, atlantic_visited)
        return pacific_visited & atlantic_visited