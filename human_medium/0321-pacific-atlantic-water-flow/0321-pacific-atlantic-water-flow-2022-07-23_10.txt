class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:  # Time: O(mn) and Space: O(mn)
       
	    rows, cols = len(heights), len(heights[0])
        pac, atl = set(), set()

        def dfs(r, c, visit, prevHeight):  # current location, set of already visited tiles, the value of the tile where we are calling the dfs function
          
		    # we will check if the index[r, c] is not already visited, row and column is inbounds and
            # the current tile should be lower than from we are coming from, it\'s the condition for waterflow mentioned
            # if any one of these conditions fails exit the dfs by returning to from we came from
            if (r, c) in visit or r < 0 or c < 0 or r == rows or c == cols or heights[r][c] < prevHeight:
                return
				
            visit.add((r, c))  # mark the tile visited(pac or atl depending on what is passed from the dfs function) when the if conditions true
			
            dfs(r + 1, c, visit, heights[r][c])  # we will next visit the tile down from the current one
            dfs(r - 1, c, visit, heights[r][c])  # up
            dfs(r, c + 1, visit, heights[r][c])  # right
            dfs(r, c - 1, visit, heights[r][c])  # left

        for c in range(cols):                            # we will traverse the first & last row by fixing the r and moving c
            dfs(0, c, pac, heights[0][c])                # first row is just next to pacific
            dfs(rows - 1, c, atl, heights[rows - 1][c])  # last row is just next to atlantic

        for r in range(rows):                            # we will traverse the first & last column by fixing the c and moving r
            dfs(r, 0, pac, heights[r][0])                # first column is just next to pacific
            dfs(r, cols - 1, atl, heights[r][cols - 1])  # last column is just next to atlantic

        return list(pac.intersection(atl))  # returns the list which contains the same [i, j] in both the sets