## RC ##
        ## APPROACH : DP ##
        
        # [
        #     [   (0,0)          (0,0) + (0,1)   ],
        #     [   (0,0)+(1,0)          ???         ]
        # ]
        # Logic 1 : dp[i][j] = matrix[i][j] + (dp[i-1][j] + dp[j][i-1] - dp[i-1][j-1])
        # take an example to understand below, how we are getting answer using total sum of elements upto that position.
        # Logic 2 : return matrix[row2][col2] + ( dp[row2][col2] - dp[row1-1][col2] + dp[row2][col2-1] - dp[i-1][j-1])
        
		## TIME COMPLEXITY : sumRegion O(1) ##
		## SPACE COMPLEXITY : O(N^2) ##
        
class NumMatrix:
    def __init__(self, matrix: List[List[int]]):
        if not matrix: return
        N, M, self.matrix = len(matrix), len(matrix[0]), matrix
        
        self.dp = [[0 for _ in range(M)] for _ in range(N)]
        self.dp[0][0] = matrix[0][0]                        # base case

        for j in range(1, M):
            self.dp[0][j] = matrix[0][j] + self.dp[0][j - 1]  # base case 1

        for i in range(1, N):
            self.dp[i][0] = matrix[i][0] + self.dp[i - 1][0]  # base case 2

        for i in range(1, N):
            for j in range(1, M):
                self.dp[i][j] = matrix[i][j] + ( self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i - 1][j - 1] )

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        if(not self.matrix):    return 0
        if(len(self.matrix) == 1 and len(self.matrix[0]) == 1): return self.matrix[0][0]
            
        result = self.dp[row2][col2]
        if(row1 > 0):               result -= self.dp[row1 - 1][col2]
        if(col1 > 0):               result -= self.dp[row2][col1 - 1]
        if(row1 > 0 and col1 > 0):  result += self.dp[row1 - 1][col1 - 1]
        return  result