class Solution:
  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
    if n == 1:
      return [0]
    gra = {} # our graph
    for ii in range(n):
      gra[ii] = []
    for k in edges:
      gra[k[0]].append(k[1])
      gra[k[1]].append(k[0])
    que = []
    curr = 0 # we use queue (my queue)
    for ii in gra.keys(): # getting leafs into our queue
      if len(gra[ii]) == 1:
        que.append(ii)
    while len(que) < n: # when all nodes will be in our array, then we know its the end of our misery
      le = len(que)
      for ii in range(curr,le):
        # print(que)
        if ii >= len(que):
          print("FU:>") # my debbuging, I don\'t have premium
        # deleting node (getting ridof leaf) is achived simply by curr += 1
        todelNode = que[ii] # number of (leaf) node we want to delete
        tocheNode = gra[todelNode][0] # node connected to todelNode (current leaf node) (toche = to check)
        gra[tocheNode].remove(todelNode)
        if len(gra[tocheNode]) <= 1: # here we check, the name of variable suddenly makes sense
          que.append(tocheNode)
      curr = le # we need to move on
    if curr != n-1:
      return que[n-2:n]
    else:
      return [que[-1]] # idea between this if is actualy pritty simple:> Im so smart