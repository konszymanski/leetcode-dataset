from collections import defaultdict
#Do we have a path higher than all other paths? if yes then we can explore that path. If not root is the MHT
#If there is such a path calculate height of other paths at each level
#Check if height is reducable from that node. IE Maximum from past nodes is less or eq to current node height
#If reducable reduce and record height
#Reduced height is the maximum of previous heights + 1 and current height
#Given previous heights were already maximum and increment by 1 each time we only need to worry about subsequent heights


class Solution(object):
    def spanChildHeights(self, parentChildList, root, childHeights = {}):
        childHeights[root] = max([1 + self.spanChildHeights(parentChildList, child, childHeights) for child in parentChildList[root]] or [0])
        return childHeights[root]
    def getMaxHeightPathNodes(self, childHeights, parentChildList, root):
        currentNode = root
        maxHeightPathNodes = []
        while currentNode != None:
            maxHeightPathNodes.append(currentNode)
            nextNodes = []
            maxChildHeight = max([childHeights[children] for children in parentChildList[currentNode]] or [0])
            maxHeightChildren = [children for children in parentChildList[currentNode] if childHeights[children] == maxChildHeight]
            if len(maxHeightChildren) > 1 or not maxHeightChildren:
                currentNode = None
            else:
                currentNode = maxHeightChildren[0]
        
        return maxHeightPathNodes
    def findMinHeightTrees(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        nodes = set([i for i in range(n)])
        parentChildList = defaultdict(lambda: set())
        childParentList = defaultdict(lambda: None)
        seenNodes = set()
        undecided = {}
        rootVal = None
        #We must fix the input of nodes it has been shown that the input is not ordered correctly
        if not edges:
            return [0]
        if len(edges) == 1:
            return edges[0]
        
        if edges[0][0] == edges[1][0]:
            rootVal = edges[0][0]
            parentChildList[edges[0][0]].add(edges[0][1])
        elif edges[0][1] == edges[1][1]:
            rootVal = edges[0][1]
            parentChildList[edges[0][1]].add(edges[0][0])
        elif edges[0][1] == edges[1][0]:
            rootVal = edges[0][0]
            parentChildList[edges[0][0]].add(edges[0][1])
        else:
            rootVal = edges[0][1]
            parentChildList[edges[0][1]].add(edges[0][0])
        seenNodes.add(edges[0][0])
        seenNodes.add(edges[0][1])

        for node1, node2 in edges[1:]:

            if node2 in seenNodes and node1 not in seenNodes:
                parentChildList[node2].add(node1)
                childParentList[node1] = node2
            else:
                parentChildList[node1].add(node2)
                childParentList[node2] = node1
            seenNodes.add(node1)
            seenNodes.add(node2)
        
        childHeights = {}
        self.spanChildHeights(parentChildList, rootVal, childHeights)
        maxHeightPathNodes = self.getMaxHeightPathNodes(childHeights, parentChildList, rootVal)
        if not maxHeightPathNodes:
            return [rootVal]
        heightNodes = defaultdict(lambda: set())
        rootedHeights = defaultdict(lambda: 0)
        pastHeights = 0
        parent = None
        for node in maxHeightPathNodes:
            childHeightList = sorted([(childHeights[child], child) for child in parentChildList[parent]])
            adjacencies = [height for height, child in childHeightList if child != node]
            adjacentHeight = max(adjacencies or [0])
            currentHeight = max(pastHeights+1, (adjacentHeight+2) if adjacencies else 0, childHeights[node])
            heightNodes[currentHeight].add(node)
            secondHighestChild = childHeightList[-2][0] if len(childHeightList) > 1 else 0
            pastHeights = max((adjacentHeight+2) if adjacencies else 0, pastHeights+1) if parent != None else (secondHighestChild + 1 if adjacencies else 0)
            parent = node
        return heightNodes[min(heightNodes)]