def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        
	# Edge case
	if n == 1 or not edges:
		return [0]

	if n == 2 and len(edges) == 1: # 2 nodes and one link between them
		return edges[0]

	--- BFS helper ---
	def dfs(node):
		height = 0
		from collections import deque
		q = deque()
		q.append(node)
		visited = set()

		while q:
			height += 1 # raduis counter
			for i in range(len(q)):
				node = q.popleft()
				visited.add(node)

				for nei in d[node]: # more like a child than a nei
					if nei not in visited:
						q.append(nei)

		return height-1


	 # --- main logic ---
	from collections import defaultdict
	d = defaultdict(list)

	# build graph/tree
	for k, v in edges:
		d[k].append(v)
		d[v].append(k)

	rootDict = defaultdict(list)
	for node in range(n):
		h = dfs(node)
		rootDict[h].append(node) # add all roots associated with that height

	minHeight = min(rootDict.keys())
	for h in rootDict:
		if h == minHeight:
			return rootDict[h]