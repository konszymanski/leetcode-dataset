class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n==1:
            return [0]
        
        neighbors = defaultdict(list)
        max_neighbors = 0
        max_neighbor_node = None
        for edge in edges:
            i,j = edge
            neighbors[i].append(j)
            neighbors[j].append(i)
            if len(neighbors[i]) > max_neighbors:
                max_neighbors = len(neighbors[i])
                max_neighbor_node = i
            if len(neighbors[j]) > max_neighbors:
                max_neighbors = len(neighbors[j])
                max_neighbor_node = j
                
        assert max_neighbors > 0
        
        # for memoization
        self.heights = {}
                
        # our best guess is that the root of the MST is a vertex with the most neighbors
        root = max_neighbor_node
        
        # keep shifting the root to its tallest child as long as that reduces the height of the rooted tree
        while True:
            heights = [(neighbor, self.height(root,neighbor,neighbors)) for neighbor in neighbors[root]]
            heights.sort(key=lambda x: x[1], reverse = True)
            if len(heights)==1:
                #if there is only one child                
                child, height = heights[0]
                if height > 0:
                    # shift the root to the child which will lower the height
                    root = child
                    continue
                else:
                    # there are only two nodes
                    return [root, child]
            else:
                # if multiple children, can lower the height by shifting root to a child that is at least 2 taller than next tallest child
                max_height_child, max_height  = heights[0]
                next_max_height = heights[1][1]
                if max_height >= next_max_height + 2:
                    # shift root to tallest child when it is at least 2 height taller than other children
                    root = max_height_child
                    continue
                elif max_height == next_max_height + 1:
                    # if tallest child is one taller than other children it is a root of a MHT
                    return [root,max_height_child]
                else:
                    # if two children have the tallest height, shifting to either of them will increase the height
                    return [root]
                
    def height(self,visited,source,neighbors):
        # use memoization
        if (visited,source) in self.heights:
            return self.heights[(visited,source)]
        
        answer = 0
        for neighbor in neighbors[source]:
            if neighbor != visited:
                answer = max(answer, 1  + self.height(source, neighbor, neighbors))
        self.heights[(visited,source)] = answer
        return answer