class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        ## I need to handle for the first element
        ## for last if first elem is less than second
        
        
        last = -1
        alternative = "Increasing"
        
        ### pre-processing for finding what the last should be
        ### when we find two elements which are different we set our alternative
        for idx in range(len(nums) - 1):
            if nums[idx] != nums[idx + 1]:
                
                ## if the current is greater than the next
                ## we want our last to be increasing, and very low to maximize length
                if nums[idx] > nums[idx + 1]:
                    alternative = "Increasing"
                    last = -1
                else:
                    ## if the current is less than the next
                    ## we want our last to be decreasing, and high to maximize length
                    alternative = "Decreasing"
                    last = 1001
                break
                
                
        length = 0
        
        for elem in nums:
            if alternative == "Increasing" and elem > last:
                alternative = "Decreasing"
                length += 1
            elif alternative == "Decreasing" and elem < last:
                alternative = "Increasing"
                length += 1
                
            ## wether it is valid or not we want our last to be the current element.
            ## if it\'s valid then it\'s a valid to make the current the last
            ## if it\'s not, then we are saying that we are using the current element to maximize for the subsequence.
            last = elem
            
        return length