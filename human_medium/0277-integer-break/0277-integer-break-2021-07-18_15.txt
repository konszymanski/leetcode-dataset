class Solution:
    def integerBreak(self, n: int) -> int:
        """
        Take a look at the below examples. Here we notice something. Once we split, we can use that data to calculate the next 
        maximum product. 
        Example: we split: 2 and 3 with answers, 1 and 2 respectively
        Now take 4, we can do it either 2 + 2 or 3 + 1 or the split of each, the max product is 4
        
        Lets take a bigger number 10:
        here we can do 2 + 8 or 2 + (split 8)
        
        The below approach maybe a little unintuitive, but lets think about it. 
        so every number we split, we split based on 2 + split(number-2)
        
        what we are looking for here is a number that cannot be further split because the max_product would be something smaller
        like split(2), max_product is 1. We use that number to split the larger number given to us, in this example its 10
        so 2 + split(10-2)
        
        But notice further here, the largest number that is bigger than its max_product split value is actually 3
        because split(3), max product is 2
        split(4), max product is 4
        
        so there is no point splitting 4..
        
        So what happens if we choose a larger number to split? say 5?
        we know for 5, spit(5) = 6
        
        lets try for 9, 5 + split(4) OR split(4) + split(5) or split(4) * 5 -> 24
            => it does not work, why? because we are missing the possibility of larger number on the right side
				left side + right side
					5            4
             
        so 3 would be the best candidate because it maximizes the right side value as well as gives a split larger than itself
		
        with 3, we can just populate dp[1],dp[2],dp[3],dp[4], we need 4 because 4-3 is 1 and split of 1 wouldn\'t work
        
        5
        3 + 2
        1 + 3 + 1
        
        
        2
        1 + 1
        
        3
        2 + 1
        1 + 1 + 1
        
        4
        2 + 2
        3 + 1
        1 + 1 + 1
        
        5 
        2 + 3
        2 + 2 + 1
        1 + 3 + 1
        1 + 1 + 1 + 
        
        6
        4 + 2
        2 + 2 + 2
        3 + 3
        3 + 2 + 1
        
        7
        4 + 3
        2 + 2 + 3
        
        8
        4 + 4
        2 + 2 + 2 + 2
        3 + 3 + 2
        
        9
        5 + 4
        3 + 3 + 3
        
        
        10
        
        2 + 8 (split 8) or not
            16
            36
        3 + 7 (split 7 or not)
            21
            36
        4 + 6 (split 6)
            36
            
        5 + 5 (split 5)
            30
            
        
        """
        
        dp = [0] * 58
        dp[0] = 0
        dp[1] = 0
        dp[2] = 1
        dp[3] = 2
        dp[4] = 4
        
        max_prod = 1
        for i in range(4, n+1):
            dp[i] = max(dp[i], (3 * (i-3)), 3 * dp[i-3])
                
        
        return dp[n]