class Solution:
    def integerBreak(self, n: int) -> int:
        memo = {}
        
        def helper(remainingAmount):
            nonlocal memo
            
            if remainingAmount == 0 or remainingAmount == 1:
                # we are done with this path
				# in case of 0 we return 1 because we don\'t want the product to cancel out to 0 in a valid path
				# in case of 1 we return 1 because there are no subproblems to explore
                return 1
            elif remainingAmount < 0:
                # this path is invalid so we return 0 to ignore this path\'s outcome in our solution
                return 0
            else:
                if remainingAmount in memo:
                    return memo[remainingAmount]
                
                # we have remaining amount left so we need to explore all our options from 1 to remainingAmount -1
				# (there\'s no point in exploring up to remainingAmount because that will always give us remaining 0 which
				# leads to solution 1 in base case)
                maxProduct = 1
                
				# we explore all solutions from 1 to remainingAmount-1
                for i in range(1, remainingAmount):
					# the result we want here is the max between:
					# - the maxProduct we found so far by exploring all options from 1 up to i-1
					# - the option of splitting remainingAmount-i into the sum of smaller numbers
					# - the option of keeping the remainingAmount-i as is without splitting it
                    maxProduct = max(maxProduct, i * helper(remainingAmount - i), i * (remainingAmount - i))
                    
                memo[remainingAmount] = maxProduct
                
                return maxProduct
            
        return helper(n)