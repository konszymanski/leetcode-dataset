class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        # store the root and divison to root
        # if two variables are connected we can find the divison else return -1
        
        class UnionFind:
            def __init__(self):
                self.root = {}
                self.rank = {}
                
            def findroot(self,x):
                if x not in self.root:
                    self.root[x] = (x,1)
                    self.rank[x] = 1
                    
                if x == self.root[x][0]:
                    return (x,1)
                # path compression
                rootX, px = self.findroot(self.root[x][0])
                self.root[x] = (rootX,self.root[x][1]*px)
                return self.root[x]

            def union(self,x,y,val):
                rootX, px = self.findroot(x)
                rootY, py = self.findroot(y)
                # union by rank
                if rootX != rootY:
                    multp = px/py*val #this is the trickiest part
                    if self.rank[rootX]>self.rank[rootY]:
                        self.root[rootY] = (rootX, multp)
                    elif self.rank[rootX]<self.rank[rootY]:
                        self.root[rootX] = (rootY, 1/multp)
                    else:
                        self.root[rootY] = (rootX, multp)
                        self.rank[rootX] +=1
               
            def calculate(self,x,y):
                if x not in self.root or y not in self.root:
                    return -1
                
                rootX, px = self.findroot(x)
                rootY, py = self.findroot(y)
                if rootX != rootY: return -1
                return 1/px*py
                       
        graph = UnionFind()
        for (a,b),n in zip(equations,values):
            graph.union(a,b,n)
            
        return [graph.calculate(a,b) for a,b in queries]