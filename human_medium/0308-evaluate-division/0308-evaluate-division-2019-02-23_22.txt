class Solution:
    def calcEquation(self, equations: \'List[List[str]]\', values: \'List[float]\', queries: \'List[List[str]]\') -> \'List[float]\':
        # Transform the input into an adjacency list representing a graph.
        # The nodes are the variables, and the edges between them are associated with weights that represent the values.
        adj = {}
        for index, variables in enumerate(equations):
            if variables[0] not in adj:
                adj[variables[0]] = []
            if variables[1] not in adj:
                adj[variables[1]] = []
            adj[variables[0]].append([variables[1], values[index]])
            adj[variables[1]].append([variables[0], 1.0/values[index]])
         
        # Initialize the output list.
        output = []
        
        # Iterate through the queries and process them.
        for query in queries:
            # If a variable does not exist in our graph, return -1.0.
            if (query[0] not in adj) or (query[1] not in adj):
                output.append(-1.0)
            # If the query divides a variable by itself, return 1.0.
            elif(query[0] == query[1]):
                output.append(1.0)
            # Perform a BFS to find the result of the query.
            else:
                output.append(self.bfs(adj, query[0], query[1]))
                
        return output
    
    def bfs(self, graph, start, end):
        # Maintain a queue of nodes to visit and the value computed so far.
        # Start with the first variable.
        queue = [(start, 1.0)]
        # Keep track of which nodes we\'ve already seen.
        seen = set()
        
        while queue:
            curr_node, val = queue.pop(0)
            seen.add(curr_node)
            # If we\'ve found the other variable, return the calculated value.
            if curr_node == end:
                return val
            # Compute the new value for each previously unseen neighbor.
            for neighbor in graph[curr_node]:
                next_node, weight = neighbor
                if next_node not in seen:
                    queue.append((next_node, val*weight))
        
        # If there\'s no way to calculate the answer (ie. underdetermined system), return -1.0.
        return -1.0