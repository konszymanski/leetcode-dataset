class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        
        """
        a. looks like topological sort. we need to keep dfs\'ing until we reach leaf . finding base leaf case is hard..
        
        q. can we use dp?
            maybe, but since there are multiple queris, i wonder if it will be optimal to try all cases.. 
            
            dp(curr, used_equations):
                for eq in equations: 
                  n = curr/eq
                  if n == query: got it , return solution
                  else: dp(n, used.add(equation))
            
            return -1
            
            since each `query` to make is different , @caching would also not work . it will be more backtracking
       
        
        """
        
        g = defaultdict(defaultdict) # dict { dict { int } }
        
        for i, (numerator, denominator) in enumerate(equations):
            g[numerator][denominator] = values[i] # numer / denom = value 
            g[denominator][numerator] = 1 / values[i] # denom / numer = 1/value
        
        def dfs(convert_from, convert_to):
            
            if convert_from in seen:
                return -1
            
            if convert_from == convert_to:
                if convert_from in g:
                    return 1
                else:
                    return -1
            
            seen.add(convert_from)
            
            for change in g[convert_from]:
                r = dfs(change, convert_to)    
                if r != -1:
                    return g[convert_from][change] * r
            
            return -1
    
        res = []
        
        for query in queries:
            seen = set()
            res.append(dfs(query[0], query[1]))
        
        return res