def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
	"""
	Note: "ab" in equations or queries do not represent a X b (a multiplied with b), 
		  it is a single variable "ab"
	:param equations:
	:param values:
	:param queries:
	:return: result of each query in queries
	"""
	graph = defaultdict(dict)

	for (x, y), value in zip(equations, values):
		graph[x][y] = value
		graph[y][x] = 1 / value  # x / y = value => y / x = 1 / value

	def query(u: str, end: str, val: float, visited: set) -> float:
		"""
		:param u: current node in the DFS traversal
		:param end: destination node in DFS traversal
		:param val: value obtained for reaching to u
		:param visited: set of all the visited node in DFS traversal
		:return: val * (value obtained for reaching from "u" to "end") and if 
				 there is no path from u to end to -1
		"""
		if u == end:
			return val

		visited.add(u)

		for v, w_uv in graph[u].items():
			if v not in visited:
				# start_node / u = val and u / v = w_uv so
				# start_node / v = val * w_uv
				out = query(v, end, val * w_uv, visited)

				if out > 0:  # out != -1, i.e. there is a path from "u" to "end"
					return out

		return -1

	output = []

	for a, b in queries:
		if a not in graph or b not in graph:
			# one of the variables is not in the graph
			output.append(-1)
		else:
			output.append(query(a, b, 1, set()))

	return output