class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        graph={}
        visit={} # visited nodes for DFS
		#Graph construction:
		#    dictionary => string : list
		#    list contains string(other node) followed by cost to reach that node
        for i in range(len(equations)):
            a,b=equations[i]
            if(a not in graph):
                graph[a]=[]
            if(b not in graph):
                graph[b]=[]
            graph[a]+=[b]
            graph[a]+=[values[i]]
            graph[b]+=[a]
            graph[b]+=[1/values[i]]
            visit[a]=False
            visit[b]=False
        self.ans=[]
        
        def dfs(v,node,dist,target):
            if(v[node]):
                return
            v[node]=True
            if(node==target):
                self.ans.append(dist)
            for i in range(0,len(graph[node]),2):
                bfs(v,graph[node][i],dist*graph[node][i+1],target)
        
        for i in range(len(queries)):
            temp_visit=copy.deepcopy(visit) # if visit was passed, values of visit would change and not reusable.
            n,t=queries[i]
            if((n not in graph) or (t not in graph)): # condition for unexisting nodes
                self.ans.append(-1)
                continue
            bfs(temp_visit,n,1,t)
            if(len(self.ans)<=i): # condition for no path from \'n\' to \'t\'
                self.ans.append(-1)
        return self.ans