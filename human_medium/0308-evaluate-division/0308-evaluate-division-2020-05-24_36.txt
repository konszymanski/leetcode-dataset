class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]: 
        """
        - BFS Solution
        - Initialize a defaultdict, and store every node as a weighted graph.
        - For example, given a/b = 2.0, we can store g[a][b] = 2.0 and g[b][a] = 1/2
        """
        g = defaultdict(dict)
        for (x, y), v in zip(equations, values):
            g[x][y] = v
            g[y][x] = 1/v
        """
        - Define a function bfs that takes in src and dst
        - if not (src and dst both in graph), return -1.0
        - pop, each time when we pop a node we check whether node is the dst.
        - If node equals to dst, we can return the value.
        - Otherwise, append neightbour (if not visited), with value v*g[cur][neighbour]
        """ 
        def bfs(src, dst):
            q, seen = deque([[src, 1.0]]), set()
            if not (src in g and dst in g): return -1.0
            while q:
                [cur, v] = q.popleft()
                if cur == dst:
                    return v
                seen.add(cur)
                for neighbour in g[cur]:
                    if neighbour not in seen:
                        q.append([neighbour, v*g[cur][neighbour]])
            return -1.0
        return [bfs(s, d) for s, d in queries]