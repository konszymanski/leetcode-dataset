class UnionFind:
    """
    For each set, always maintain ele/root_ele and root_ele/ele
    """
    def __init__(self):
        self.size = {}
        self.parent = {}
        self.relation = {} # store {ele1: {ele2: ele1/ele2} }
    def add(self, ele):
        self.size[ele] = 1
        self.parent[ele] = None
        self.relation[ele] = {ele : 1} # ele/ele =1
    def union(self, a, b, value):
        """
        merge two set by size if not yet, and store the relation
        Maintain relation between child and parent
        """
        root_a, a_by_roota = self.find(a) # = self.relation[a][root_a]
        root_b, b_by_rootb = self.find(b) # = self.relation[b][root_b]
        # if b not in self.relation[a]:
        #     self.relation[a][b] = value
        #     self.relation[b][a] = 1/value

        if root_a == root_b:
            return
        if self.size[root_a] >= self.size[root_b]: # root_b -> root_a
            self.parent[root_b] = root_a
            self.size[root_a] += self.size[root_b]
        else: # root_a -> root_b
            self.parent[root_a] = root_b
            self.size[root_b] += self.size[root_a]
        
        # some algebra to maintain relation
        if root_b not in self.relation[root_a]:
            self.relation[root_a][root_b] = \\
                1/a_by_roota * b_by_rootb * value # root_a/root_b
            self.relation[root_b][root_a] = \\
                1/ self.relation[root_a][root_b] # root_b/root_a

    def find(self, ele):
        """
        Recursive find root with additional:
        1. path compression
        2. store relation as value divided by root
        
        return (root, relation as value divided by root)
        """
        if self.parent[ele] is not None:
            root, relation_to_root = self.find(self.parent[ele])
            if root not in self.relation[ele]:
                self.relation[ele][root] = \\
                    self.relation[ele][self.parent[ele]] * relation_to_root
                self.relation[root][ele] = 1/ self.relation[ele][root]
            self.parent[ele] = root
            return root, self.relation[ele][root]
        else: # base case
            return ele, 1

class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        ## Any variable can be grouped together through a chain of var
        ## E.g. three var in 2 equations are grouped into one set
        ## Algo: O(#equation + #query) runtime, O(#var) space
        #       iterate through equations to build UF sets
        #           group together the two vars in the equ.
        #           may need to build relation in find, ele1 -> root, root - > ele2
        #       iterate through query
        #           if a,b in same UF set:
        #               store relation a/root * root/b
        #           else cannot to determined, store -1
        uf = UnionFind()

        # iterate through equations to build UF sets
        for (a,b), value in zip(equations, values):
            # first add to indiv set in uf
            if a not in uf.parent:
                uf.add(a)
            if b not in uf.parent:
                uf.add(b)
            # group together, since their relation is given by values
            uf.union(a,b, value)
        
        # iterate through query
        answers = []
        for a,b in queries:
            # check if in uf:
            if (a not in uf.parent) or (b not in uf.parent):
                answers.append(-1.0)
                continue
            # if b in uf.relation[a]:
            #     answers.append(uf.relation[a][b])
            #     continue

            # also establish the relation: a->root,root->a
            root_a, _ = uf.find(a) # = self.relation[a][root_a]
            root_b, _ = uf.find(b) # = self.relation[b][root_b]
            if root_a == root_b:
                answers.append( uf.relation[a][root_a] * uf.relation[root_a][b] )
            else:
                answers.append(-1.0)
        return answers