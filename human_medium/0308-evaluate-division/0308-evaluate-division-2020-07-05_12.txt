class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        """
        union find
        """
        # initiate union-find data structure
        # e.g. a / b = k
        # euqs[a] = b; vals[a] = k
        equs = {}
        vals = {}
        
        # find the root and corresponding value for a given variable x
        # so that x / root_x = value
        def find(x):
            if equs[x] != x:
                equs[x], v = find(equs[x])
                vals[x] *= v
            return equs[x], vals[x]
        
        # union two variables based on a pair of equation and value, update the value simultaneously
        def union(a, b, v):
            if a not in equs:
                equs[a] = a
                vals[a] = 1
            if b not in equs:
                equs[b] = b
                vals[b] = 1
            root_a, v_a = find(a)
            root_b, v_b = find(b)
            """ some math here
            a / b = v
            a / root_a = v_a
            b / root_b = v_b
            => root_a / root_b = a * v_b / b / v_a
            """
            equs[root_a] = root_b
            vals[root_a] = v * v_b  / v_a
            
        # calclulate a / b
        def calculate(a,b):
            if a not in equs or b not in equs:
                return -1.0
            root_a, v_a = find(a)
            root_b, v_b = find(b)
            if root_a != root_b:
                return -1.0
            return v_a / v_b
        
        # main body
        for (a, b), v in zip(equations, values):
            union(a, b, v)
            
        return [calculate(a, b) for a, b in queries]