class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
		""" 
		Dynamic sliding window method
		use a HashMap to count the frequency of each letter and iterate through the string 
		to add one letter at a time in the window. Also, keep track the most frequent character
		in the current window call it max_char_count
		At any time, we have  a window with one letter repeating max_char_cont times and we 
		need to replace the remaining characters. There are two cases:
		1.  the remaining letters are less than or equal to k, we can replace them all.
		2.  we have more than k remaining letters, we should shrink the window as we cannot replace more than k letters
		Note: while shrinking the window, it doesn\'t matter whether or not to update the max_char_count.
		Since we only care about the longest valid substring, the sliding windows do not have to shrink, even if a window may cover an invalid substring. 
		"""
		# HashMap to count the frequency of each letter.
		char_map, window_start, max_length, max_char_count = {}, 0, 0, 0
		# iterate through the string to add one letter at a time in the window
		for window_end in range(len(s)):
			right_char = s[window_end]
			if right_char not in char_map:
				char_map[right_char] = 0
			char_map[right_char] += 1
			# keep track of the count of the maximum repeating letter in any window 
			max_char_count = max(max_char_count, char_map[right_char])
			# if have more than k remaining elements to repalce, shrink the window
			if window_end - window_start + 1 > k:
				left_char = str1[window_start]
				frequency_map[left_char] -= 1
				window_start += 1
			max_length = max(max_length, window_end - window_start+1)
		return max_length
"""
time complexity: O(N) where \u2018N\u2019 is the number of letters in the input string.
space complexity: As we only consider upper level characters in the input string, 
we can conclude that the space complexity will be O(26) to store each letter\u2019s frequency
in the HashMap, which is O(1)
"""