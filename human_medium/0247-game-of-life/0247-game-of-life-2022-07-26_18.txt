class Solution:
    # O(N*M) Time | O(1) Space
    def gameOfLife(self, board: List[List[int]]) -> None:
        row_length = len(board)
        col_length = len(board[0])

        for row in range(row_length):
            for col in range(col_length):
                neighbors = self.get_neighbors(row, col, board)

                live_neighbors = 0
                for neighbor_row, neighbor_col in neighbors:

                    if abs(board[neighbor_row][neighbor_col]) == 1:
                        live_neighbors += 1

                live_cell = board[row][col] == 1
                
                # Rules
                under_population = live_neighbors < 2
                over_population = live_neighbors > 3
                reproduction = live_neighbors == 3
                next_generation = live_neighbors == 2 or live_neighbors == 3

                # Rule 2
                if live_cell and next_generation:
                    continue
                    
                if live_cell:
                    # Rule 1 and 3
                    if under_population or over_population:
                        board[row][col] = -1
                
                # Rule 4
                elif reproduction:
                    board[row][col] = 2

        
        # Update board with next state (final values)
        for row in range(row_length):
            for col in range(col_length):
                if board[row][col] > 0:
                    board[row][col] = 1
                else:
                    board[row][col] = 0
                    
    
    def get_neighbors(self, row, col, board):
        row_length = len(board)
        col_length = len(board[0])

        down = row + 1 < row_length
        up = row - 1 >= 0
        right = col + 1 < col_length
        left = col - 1 >= 0

        neighbors = []
        
        # ADJACENT NEIGHBORS
        if down:
            neighbors.append((row + 1, col))
        if up:
            neighbors.append((row - 1, col))
        if right:
            neighbors.append((row, col + 1))
        if left:
            neighbors.append((row, col - 1))

        # DIAGONAL NEIGHBORS
        if up and right:
            neighbors.append((row - 1, col + 1))
        if up and left:
            neighbors.append((row - 1, col - 1))
        if down and right:
            neighbors.append((row + 1, col + 1))
        if down and left:
            neighbors.append((row + 1, col - 1))

        return neighbors