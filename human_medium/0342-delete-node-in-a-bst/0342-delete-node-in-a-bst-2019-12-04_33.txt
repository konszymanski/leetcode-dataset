class Solution:
    #Utility function . read deleteNode first
    def findMinRight(self,root: TreeNode) -> TreeNode:
        #Just go left until there are no more left-nodes . 
        if root.left:
            return self.findMinRight(root.left)
        return root
        
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        #Sanity check
        if not root : return None
        
        #---Find Node to delete:
        #Search right
        if key>root.val :
            root.right = self.deleteNode(root.right,key)
        #Search left
        elif key<root.val:
            root.left = self.deleteNode(root.left,key)
        #Found target
        elif key==root.val:
            # BST Node deletion can be devided into 3 cases ;
            
            # Case 1 : target node only has a left child
            if not root.right:
                #We can simply return the left sub-tree and connect it to parent using the recursion
                return root.left
            
            #Case 2 : target node only has a right child
            if not root.left :
                #We can simply return the right sub-tree
                return root.right
            
            #Case 3: target node has 2 childern . The solution is , to reduce the problem to one of the 
            #cases above . Find the minimum value in the left sub-tree/maximum value in right sub-tree ; 
            #it doesn\'t matter which one , since both of them preserve the BST properties.
            minRight = self.findMinRight(root.right)
            root.val = minRight.val
            #Now we\'ve swapped the root and minRight values , thus we can set a new deletion target - 
            #minRight.val which has only 1 child since function goes left in 
            #subtree until there are no more left nodes - which means a node has only 1 child)
            root.right = self.deleteNode(root.right,minRight.val)
        return root