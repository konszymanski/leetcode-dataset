class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        # Base Case: if root is None return nothing.
        if(not root):
            return
        # Recursively check if the key Value is lesser than the root Value in the Tree to delete and traverse the tree.
        if(key<root.val):
            root.left = self.deleteNode(root.left,key)
            return root
        # Recursively check if the key Value is greater than the root Value in the Tree to delete and traverse the tree.
        elif(key>root.val):
            root.right = self.deleteNode(root.right,key)
            return root
        # if the root is leaf Node then delete the Node and pass nothing.
        if(root.left is None and root.right is None):
            root = None
            return 
        # if left subTree is None then delete the Node and pass the right subTree as root
        if(root.left is None):
            temp = root.right
            root = None
            return temp
        # if right subTree is None then delete the Node and pass left subTree as root
        if(root.right is None):
            temp = root.left
            root = None
            return temp
        # if both subTrees exist we need to get the minimum from right subTree and copy its value in the target and delete the duplicate minimum value in the SubTree.
        parent = root
        rC = root.right
        # Search for minimum in the right SubTree
        while(rC.left!=None):
            parent = rC
            rC = rC.left
        # Copy the minimum value in the targetted Node.
        root.val = rC.val
        # Delete Duplicate from right SubTree
        if(parent!=root):
            parent.left = rC.right
        else:
            parent.right = rC.right
        return root