class Solution:
    def getSum(self, a: int, b: int) -> int:
        MASK = 0xFFF
        INT_MAX = 0x7FF
        # using this we clip off the bits that goes beyond limit
        # each F = 4 bits, hence FFF = 12 bits since our input limit
        # is {-1000, 1000} and our output limit can be {-2000, 2000}
        # 12 bits as in 2056,1024,512,256,128,64,32,16,8,4,2,1
        
        while b != 0:
            # In basic add operation, 
            # like bits always equate to 0, i.e. 1 + 1 = 0,  0 + 0 = 0
            # unlike bits always equate to 1, i.e. 1 + 0 = 1, 0 + 1 = 1
            # This is exactly the same way XOR works, so we use XOR gate 
            sum_val = (a ^ b) & MASK
            
            # In basic add operate, we get carry only when both the operands are 1
            # i.e. 1 + 1 = 0 (carry = 1)
            # This is exactly the same way AND works, so we use AND Gate to extract carry
            # if carry is present and shift to left by 1, cause we usually add carry to left digit
            carry = ((a & b) << 1) & MASK
			
			# we applied mask to both operations to take care about boundary
            # which needs for both positive and negative
        
            a = sum_val
            b = carry
        
        if a > INT_MAX:
            a = ~ (a ^ MASK)
            # (a ^ mask) XOR masking clips off the bits outside the range & 
            # inverts the current bits in range (side effect)
            # ~(a ^ mask) fixed that previous side effect by again inverting bits using NOT
        return a