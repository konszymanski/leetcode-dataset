class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        
        memo = {}
        
        def solve(root,robbed_lvl,curr_lvl):
            if not root:
                return 0
            k = (root,robbed_lvl)
            if k in memo:
                return memo[k]
            
            if robbed_lvl==curr_lvl-1:
                #robbed prev level,hence skip this level
                memo[k] = \\
            solve(root.left,robbed_lvl,curr_lvl+1)+\\
            solve(root.right,robbed_lvl,curr_lvl+1)
            
            else:
                #robbed 2 or more levels before
                memo[k] = max(
                    root.val+solve(root.left,curr_lvl,curr_lvl+1)+\\
                    solve(root.right,curr_lvl,curr_lvl+1), #rob curr lvl
                    solve(root.left,robbed_lvl,curr_lvl+1)+\\
                    solve(root.right,robbed_lvl,curr_lvl+1) #or skip robbing curr lvl
                )
            
            return memo[k]
            
        return solve(root,-inf,0)