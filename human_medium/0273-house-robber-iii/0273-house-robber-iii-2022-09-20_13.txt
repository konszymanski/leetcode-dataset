# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        \'\'\'
        TOP DOWN APPROACH 1 - SIMPLE RECURSION (TLE 122/124)
        
        -- fails as we are not storing the value of the segment instead evaluating the same segment of tree again and again.
        
        if root==None:
            return 0
            
        val = 0
        
        if root.left != None:
            val += self.rob(root.left.left) + self.rob(root.left.right)   
			// here we are going to apply dfs of "left grandchilds" of our \'root\' node. 
			// Now this value can be saved to use when we apply dfs on the " left child" of our \'root\' node at the return statement later
            
        if root.right !=None:
            val += self.rob(root.right.left) + self.rob(root.right.right) // Similarly for right subtree.
            
        return max(root.val + val,self.rob(root.left)+self.rob(root.right))
        
        \'\'\'
        
        # TOP DOWN APPROACH 2 - MEMOIZATION (124/124)
		# Here we use a tuple to store the value with node and without node at every node and then use the same to evaluate further.
		# Thereby preventing ourselves from unncessary evalutations.
        
        def dfs(root):
            if not root:
                return [0,0]            #[with current node, without current node]
            left = dfs(root.left)
            right = dfs(root.right)
            return [root.val + left[1] + right[1],max(left)+max(right)]
            # [
					with current node value will be -> current value + value without the child node, 
					without current node value will be -> max of vaue at last node as it can be anything (including the last node or not including the last node)	
			  ]
        
        res = dfs(root)
        return max(res)