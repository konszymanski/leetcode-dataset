class Solution(object):
    def pathSum(self, root, sum):
        def helper(root, mem):
            if(not root):
                return 0 
			# 1st part: To store value that we are looking for next
			# Eg: sum is 5. We are visiting 8. 8 - 5 = 3, we are looking for a 3 from now on
			# 2nd part: Everytime we visit a new node, we deduce the node value to every number in mem
			# Eg from the above example: We were looking for 3. Now we visit a new node which is 1, so we do 3 - 1. We are looking for 2 now on instead of 3.
            next_mem = [sum - root.val] + [m - root.val for m in mem]
			# case1: current node is the sum we are looking for
			# case2: Because there are different paths that are looking for the same value, so we count in total how many path are looking for this value
			# Then, Visit the left node and right node
            return int(root.val == sum) + mem.count(root.val) + helper(root.left, next_mem) + helper(root.right, next_mem)
        return helper(root, [])