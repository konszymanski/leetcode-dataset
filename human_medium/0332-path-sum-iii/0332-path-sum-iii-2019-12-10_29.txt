# Time: O(n^2) - recreates arr (n) for each node
# Space: O(n*logn) - array size (n) for each node (lg(n) nodes) for a path
def pathSum(self, root: TreeNode, sum: int) -> int:
    self.count = 0
	def runDFS(node, arr):
		if not node:
			return arr

		arr = [num + node.val for num in arr] + [node.val]

		for num in arr:
			if num == sum:
				self.count += 1

		runDFS(node.left, arr)
		runDFS(node.right, arr)

	runDFS(root, [])
	return self.count