from functools import lru_cache
from typing import List


class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:

        def tokenize(expression): #Firstly split expression into 2 stacks of elements and operators
            nums = []
            signs = []

            buffer = \'\'
            for i, c in enumerate(expression):

                if c in \'+-*\':
                    nums.append(int(buffer))
                    buffer = \'\'
                    signs.append(c)
                else:
                    buffer = buffer+c

            nums.append(int(buffer))

            return nums, signs

        nums, signs = tokenize(expression)

        
        @lru_cache(None)
        def evale(l,m,r):
            if m == \'*\':
                return l*r
            if m == \'+\':
                return l+r
            if m == \'-\':
                return l-r

        @lru_cache(None)
        def traverse(start, end):
            """Returns all evalulated combinations from start to end"""
            res = []

            if start == end:
                return [ nums[start] ]

            elif start + 1 == end:
                res.append(evale(nums[start],signs[start],nums[end]))
            elif start + 2 == end:
                # (a+b)-c and a+(b-c)
                res.append(evale(nums[start],signs[start], traverse(start+1,end)[0]))
                res.append(evale(traverse(start,start+1)[0],signs[end-1],nums[end]))
                
            elif start + 2 < end:
			    # Then every higher length is a combination of the smaller lengths
				# Seperated by mid way pointer ptr
                for ptr in range(start,end):
                    lhs=traverse(start,ptr)
                    rhs=traverse(ptr+1,end)
                    for l in lhs:
                        for r in rhs:
                            res.append(evale(l,signs[ptr],r))


            return res

        return (traverse(0, len(signs)))