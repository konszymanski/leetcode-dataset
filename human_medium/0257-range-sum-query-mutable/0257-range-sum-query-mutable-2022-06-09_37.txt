class NumArray:

    def __init__(self, nums: List[int]):
        def build(si, seg_start, seg_end):
            if seg_start == seg_end:
                self.seg_tree[si] = nums[seg_start]
                return
            seg_mid = seg_start + (seg_end - seg_start) // 2
            build(2*si + 1, seg_start, seg_mid)
            build(2*si + 2, seg_mid + 1, seg_end)
            self.seg_tree[si] = self.seg_tree[2*si + 1] + self.seg_tree[2*si + 2]
                
        self.n = len(nums)
        # self.seg_tree = defaultdict(int) # you can save a few slots by using a dict instead of an array or just use 4*n
        h = (int)(math.ceil(math.log2(self.n)))
        self.seg_tree = [0] * (2 * (2 ** h) - 1)
        build(0, 0, len(nums) - 1)

    def update(self, index: int, val: int) -> None:
        def update_node(idx, val, si, seg_start, seg_end):
            if seg_start == seg_end:
                self.seg_tree[si] = val
                return
            
            seg_mid = seg_start + (seg_end - seg_start) // 2
            if idx <= seg_mid:
                update_node(idx, val, 2*si + 1, seg_start, seg_mid)
            else:
                update_node(idx, val, 2*si + 2, seg_mid + 1, seg_end)
            self.seg_tree[si] = self.seg_tree[2*si + 1] + self.seg_tree[2*si + 2]
            
        return update_node(index, val, 0, 0, self.n - 1)

    def sumRange(self, left: int, right: int) -> int:
        def get_sum(si, seg_start, seg_end, range_start, range_end):
            if range_end < seg_start or seg_end < range_start:
                return 0
            elif range_start <= seg_start and seg_end <= range_end:
                return self.seg_tree[si]
            
            seg_mid = seg_start + (seg_end - seg_start) // 2
            left_sum = get_sum(2*si + 1, seg_start, seg_mid, range_start, range_end)
            right_sum = get_sum(2*si + 2, seg_mid + 1, seg_end, range_start, range_end)
            return left_sum + right_sum

        return get_sum(0, 0, self.n - 1, left, right)