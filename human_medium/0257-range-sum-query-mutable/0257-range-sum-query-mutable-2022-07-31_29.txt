# Binary Indexed Tree implementation
class BIT:
    def __init__(self, size):
        self.nums = [0] * (size+1)
    def update(self, ind, val):
        while ind < len(self.nums):
            self.nums[ind] += val
            ind += (ind&-ind)       # flip last set bit e.g. 101 -> 100, then add
    def getsum(self, ind):
        sum = 0
        while ind > 0:
            sum += self.nums[ind]
            ind -= (ind&-ind)       # flip last set bit e.g. 101 -> 100, then subtract
        return sum

class NumArray:
    def __init__(self, nums: List[int]):
        self.bit = BIT(len(nums))
        self.nums = nums
        for i, v in enumerate(nums):
            self.bit.update(i+1, v)

    def update(self, index: int, val: int) -> None:
        diff = val - self.nums[index]
        self.bit.update(index+1, diff)
        self.nums[index] = val

    def sumRange(self, left: int, right: int) -> int:
        # BIT is 1 based tree, right will be added by 1
        # For left we need sum of vales that left to the left means left-1
        # Instead of getting sum for left-1, we will search for only left, as BIT is 1 based tree.
        return self.bit.getsum(right+1) - self.bit.getsum(left)