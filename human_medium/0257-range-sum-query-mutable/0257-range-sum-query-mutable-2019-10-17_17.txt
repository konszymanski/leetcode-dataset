class NumArray:
    def __init__(self, nums: List[int]):
        self.nums = nums
        self._tree = [0]*4*len(nums)
        if self.nums:
            self._build(0, 0, len(nums)-1)
        
    def _build(self, root_idx, left, right):
        if left == right:
            self._tree[root_idx] = self.nums[left]
            return self._tree[root_idx]
        
        l_child = 2*root_idx+1
        r_child = 2*root_idx+2
        mid = (left+right)//2
        self._tree[root_idx] = self._build(l_child, left, mid) + self._build(r_child, mid+1, right)
        return self._tree[root_idx]
    
    def _update(self, root_idx, left, right, i, val):
        if left == right:
            self._tree[root_idx] = val
            return 
        
        l_child = 2*root_idx+1
        r_child = 2*root_idx+2
        mid = (left+right)//2
        if i <= mid:
            self._update(l_child, left, mid, i, val)
        else:
            self._update(r_child, mid+1, right, i, val)
        self._tree[root_idx] = self._tree[l_child] + self._tree[r_child]
    
    def _query(self, root_idx, left, right, q_left, q_right):
        if q_left == left and q_right == right:
            return self._tree[root_idx]
        
        l_child = 2*root_idx+1
        r_child = 2*root_idx+2
        mid = (left+right)//2
        if mid < q_left:
            return self._query(r_child, mid+1, right, q_left, q_right)
        if q_right <= mid:
            return self._query(l_child, left, mid, q_left, q_right)
        
        return self._query(l_child, left, mid, q_left, mid) + self._query(r_child, mid+1, right, mid+1, q_right)
        
    def update(self, i: int, val: int) -> None:
        self._update(0, 0, len(self.nums)-1, i, val)

    def sumRange(self, i: int, j: int) -> int:
        return  self._query(0, 0, len(self.nums)-1, i, j)