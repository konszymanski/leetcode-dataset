class NumArray:

    def __init__(self, nums: List[int]):
        self.n = len(nums)
        height = ceil(log2(self.n))  # segment tree contains a max of 2^(height+1)-1 nodes
        self.nums = nums
        self.tree = [0] * (2 ** (height+1)-1)
        self._build(0, self.n-1, 0)

    def update(self, index: int, val: int) -> None:
        diff = val - self.nums[index]  # difference between old and new value
        self.nums[index] = val
        self._update(diff, 0, self.n-1, index, 0)

    def sumRange(self, left: int, right: int) -> int:
        return self._sumRange(left, right, 0, self.n-1, 0)

    # private
    def _build(self, left, right, i):
        if left == right:
            self.tree[i] = self.nums[left]
        else:
            mid = (left+right)//2
            self.tree[i] = self._build(left, mid, i*2+1) + self._build(mid+1, right, i*2+2)
        return self.tree[i]
    
    def _update(self, diff, seg_left, seg_right, i, tree_i):
        if seg_left <= i <= seg_right:
            self.tree[tree_i] += diff
            
            if seg_right > seg_left:  # update relevant segments 
                mid = (seg_left+seg_right)//2
                self._update(diff, seg_left, mid, i, tree_i*2+1)
                self._update(diff, mid+1, seg_right, i, tree_i*2+2)
    
    def _sumRange(self, q_left, q_right, seg_left, seg_right, tree_i):
        if seg_left > q_right or seg_right < q_left:
            return 0
        elif seg_left >= q_left and seg_right <= q_right:
            return self.tree[tree_i]
        else:
            mid = (seg_left+seg_right)//2
            return self._sumRange(q_left, q_right, seg_left, mid, tree_i*2+1) +\\
                self._sumRange(q_left, q_right, mid+1, seg_right, tree_i*2+2)
        


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(index,val)
# param_2 = obj.sumRange(left,right)