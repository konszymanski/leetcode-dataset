\'\'\'
w: prime factorization
h: a little bit math here:
    the number meet the requirement must have form: 
         A = 2^i * 3^j * 5^k
    e.g. 1 = 2^0 * 3^0 * 5^0
         2 = 2^1 * 3^0 * 5^0
         3 = 2^0 * 3^1 * 5^0
         5 = 2^0 * 3^0 * 5^1

    then a naive method is that we use a heap,
    push all the value with all possibility of (i,j,k)
    and get the n-th largest one, however this would 
    cause LTE error since (1690)^3 > 10^9

    so we need to borrow some idea from Dynamic Programming and Greedy
    Note that:
    1) for any ugly number A, the number (2*A, 3*A, 5*A) must also be a 
        ugly number (DP)
    2) every step, in order to get the number that is cloer
        to the previous one, we only increase i or j or k by 1 
        we only the smallest number to multiply with 2 or 3 or 5
        in order to get a possible small number (Greedy)
        this can be done with heap since the top element in the heap
        is always the smallest one after current operation
\'\'\'
import heapq
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        if n == 1:
            return 1
        h = [1]
        mul = [2, 3, 5]
        seen = set([1])
        res = []
        while len(res) <= n:
            cur = heapq.heappop(h)
            res.append(cur)
            for m in mul:
                if cur * m not in seen:
                    seen.add(cur*m)
                    heapq.heappush(h, cur * m)

        return res[n-1]