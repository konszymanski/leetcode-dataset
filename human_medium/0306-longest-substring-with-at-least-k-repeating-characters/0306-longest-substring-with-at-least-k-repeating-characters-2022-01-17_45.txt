from collections import defaultdict, deque
from itertools import chain


def longest_substring(s: str, f: int, t: int, k: int) -> int:
    """
    :param s:
    :param f:
    :param t:
    :param k:
    :return: finding longest substring of s[f:t+1] such that each
             character of it repeats at least k times
    """
    substring_len = t - f + 1

    if substring_len < k:
        return 0

    e_indices = defaultdict(deque)

    for i in range(f, t + 1):
        e_indices[s[i]].append(i)

    bad_indices = chain.from_iterable(indices for indices in e_indices.values() if len(indices) < k)
    first_bad_index = next(bad_indices, None)

    if first_bad_index is None:  # each character repeats k times
        return substring_len

    bad_indices = chain((first_bad_index,), bad_indices)
    output, prev = 0, f

    for i in bad_indices:
        output = max(output, longest_substring(s, prev, i - 1, k))
        prev = i + 1
    else:
        output = max(output, longest_substring(s, prev, t, k))

    return output


class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        return longest_substring(s, 0, len(s) - 1, k)