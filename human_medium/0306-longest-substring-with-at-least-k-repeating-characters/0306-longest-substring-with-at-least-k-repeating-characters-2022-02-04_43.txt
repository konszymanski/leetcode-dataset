class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        # to help with the recursion
        # set a base condition to return 0
        # when we encounter an empty slice
        if len(s) == 0: return 0
        
        # create a counter for the
        # current input string to discard
        # invalid chars i.e. count(char) < k
        counter = Counter(s)
        
        # keep a count for the max
        # substring count for the current
        # recursion level
        out = 0
        
        # loop over the current input string
        for i in range(len(s)):
            
            # if any char is invalid
            # split the input string into
            # two and recursively pass them
            if counter[s[i]] < k:
                out = max(self.longestSubstring(s[:i],  k), self.longestSubstring(s[i+1:], k))
                # since we\'re going to anyway
                # check the right substring
                # there\'s no point in continuing
                # with this loop after encountering
                # an invalid char
                break
                
            # if this input string
            # doesn\'t have any invalid
            # char, it means the max length
            # would be the whole string, so
            # keep a track of the same
            out += 1
        
        return out