class Solution:
    # backtracking with memoization, or dp
    # O(n * u), O(u) where u is the number of unique targets vs the corresp count returned
    # for each recursion we run the loop for n iterations
    def combinationSum4(self, candidates: List[int], target: int) -> int:
        @lru_cache(maxsize = None)
        def backtrack(target):
            count = 0            
            if target > 0:
                i = 0
                while i < len(candidates) and target - candidates[i] >= 0:
                    # Our array is sorted so there\'s no point executing this loop once target - candidates[i] < 0
                    # because all the elements candidates[i + x] are going to be > candidates[i]
                    # this saves a significant amount of time
                    count += backtrack(target - candidates[i])
                    i += 1
                    
                return count
            else:
                return 1
        
        candidates.sort()
        
        return backtrack(target)