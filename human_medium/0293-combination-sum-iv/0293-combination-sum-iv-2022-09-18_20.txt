def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self.ans= []
  
        self.nums = candidates
        self.nums.sort()
        minvalue = self.nums[0]
        # just correct the whole values into positive numbers by minusing most negative number (addvalue)
        addvalue = 0
        if minvalue < 0:
            addvalue = - minvalue
        self.newnums = [n + addvalue for n in self.nums]    
         
        # add back the targetlen*addvalue to the target number to perform normal combination sum
        # set the targetlen range max boundary to be max possible target number divided by smallest adjust number or 1 
        for targetlen in range((target + len(self.newnums) * addvalue)//max(1, self.newnums[0])+1):
       
            self.dfs(0, [], target + targetlen * addvalue, targetlen)
        return   self.ans 

    def dfs(self, i, path, target, targetlen):
        
        if targetlen < 0 or target < 0:
            return
        
        if target == 0 and targetlen == 0:
            self.ans.append(path[:])

        for j in range(i, len(self.nums)):
            if target < self.newnums[j]:
                break
            self.dfs(j , path + [self.nums[j]], target - self.newnums[j], targetlen - 1)