class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        # Top down approach
        memo = {}
        def dfs(target):
            if target in memo:
                return memo[target]
            if target < 0:
                return 0
            if target == 0:
                return 1
            combinations = 0
            for index in range(len(nums)):
                combinations += dfs(target - nums[index])
            memo[target] = combinations
            return memo[target]
        return dfs(target)
    
        # Bottom up approach
        dp = [0]*(target + 1)
        dp[0] = 1
        for index in range(len(dp)):
            for num in nums:
                if num <= index:
                    dp[index] += dp[index - num]
        return dp[target]
    
    \'\'\'
    Bottom Up
    [1,2,3]
    dp[0] = 1
    dp[1]= dp[1 - 1] + dp[1 - 2] + dp[1 - 3] = 1 + 0 + 0 = 1
    dp[2] = dp[2 - 1] + dp[2 - 2] + dp[2 - 3] = dp[1] + dp[0] + dp[-1] = 1 + 1 + 0 = 2
    dp[3] = dp[3-1] + dp[3-2]+dp[3-3] = dp[2] + dp[1]+ dp[0] = 2 + 1 + 1 = 4
    dp[4] = dp[4 - 1] + dp[4 - 2] + dp[4 -3] = 4 + 2 + 1 = 7
    
    Top down => There ar different redundant works.
    dfs(4) =>dfs(3) + dfs(2) + dfs(1) 
    dfs(3) =>dfs(2) + dfs(1) + dfs(0)
    dfs(2) =>dfs(1) + dfs(0)
    dfs(1) =>dfs(0)
    
    From the above relations
    dfs(4) =>  dfs(2) + dfs(1) + dfs(0) + dfs(2) + dfs(1)
            =>2*dfs(2) + 2*dfs(1) + dfs(0)
            =>2*(dfs(1) + dfs(0)) + 2*dfs(1) + dfs(0)
            =>2*dfs(1) + 2*dfs(0) + 2*dfs(1) + dfs(0)
            =>4*dfs(1) + 3*dfs(0)
            =>7*dfs(0)
            \'\'\'