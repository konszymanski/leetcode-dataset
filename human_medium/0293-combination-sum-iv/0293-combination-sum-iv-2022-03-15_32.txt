class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = {}
        return self.dfs(nums, target, dp)
        
    # backtracking with dp
    def dfs(self, nums, target, dp):
        # BASE CASES
        # your path lead you to
        # the target being zero or
        # the required path
        if target == 0:
            return 1
        # at any point if your target becomes <0
        # it means the current path is not feasible
        # backtrack, return 0
        elif target < 0:
            return 0
        elif target in dp:
            return dp[target]
        
        # for every num, recursively
        # calculate the num(ways) to reach
        # target
        out = 0
        for i in range(len(nums)):
            # when you consider the current num[i]
            # the target also reduces by num[i]
            # so pass the updated target for recursion
            #
            # store all the ways possible for given
            # target in out to cache it later on
            out += self.dfs(nums, target-nums[i], dp)
            
        dp[target] = out
        return out