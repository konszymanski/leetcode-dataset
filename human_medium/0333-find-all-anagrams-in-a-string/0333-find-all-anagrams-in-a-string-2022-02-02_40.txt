class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        
        sl, pl = len(s), len(p)
        ans = []
        
        # according to the question, p has to be shorter than s 
        # or there will be no valid anagrams --> return []
        if sl < pl:
            return ans
        
        # using sliding windows, 
        # left and right pointer both starts from the longer str s
        l, r = 0, 0
        # build a counter to check 
        # if the number of each letter in anagrams is same as p
        count = collections.Counter(p)
        
        # for sliding window, we need to keep the max length of the window not exceed the pl
        # also, when right pointer moves out of the str s which means we\'ve finished the traversal
        # plus, left pointer must smaller than the right pointer to maintain our window
        while r < sl and (0 <= r - l < pl):
            # There would be three conditions:
            # 1. expand the window --> right += 1
            # 2. reduce the window --> left += 1
            # 3. The window frames a valid anagram --> start over from next letter
            
            # condition 1: the letter in s is one of the letter in p
            if s[r] in p and count[s[r]] != 0:
                # reduce the count in counter to record we\'ve already find it
                count[s[r]] -= 1
                # expand the window to check next
                # cbae --> cbae
                # | |      |  |
                r += 1
                
                # if we\'ve find all letters in p (all counts are reduced to 0)
                if all(v == 0 for v in count.values()): 
                    # record the start index (left pointer location)
                    ans.append(l)
                    # reduce the window --> move it to right with stride 1 to check next 
                    # cbae --> cbae
                    # |  |      | |
                    count[s[l]] += 1
                    l += 1
            
            # condition 2: the right pointer find a repeated letter
                # reduce the window until make it not repeated
                # abcb --> abcb -- > abcb
                # |  |      | |       | |
            elif s[r] in p and count[s[r]] == 0:
                # find the repeated letter
                while l < r and s[l] != s[r]:
                    count[s[l]] += 1
                    l += 1
                # move the left pointer to the letter next to it
                # and remove the count record from our counter
                count[s[l]] += 1
                l += 1
            
            # condition 2:
                    # cbaeb --> cbaeb
                    #  | |          |  <-- both l and r are here
            elif s[r] not in p:
                r += 1
                l = r
                # initial our counter becuase we need to start over
                count = collections.Counter(p)
                
        return ans