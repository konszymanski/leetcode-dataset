class UnionFind:
    def __init__(self, size):
        self.parent = [i for i in range(size)]
        self.rank = [1] * size
    
    def find(self, x): # path compression
        if self.parent[x] == x:
            return x
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y): # union by rank
        rootX  = self.find(x)
        rootY =  self.find(y)
        if rootX == rootY:
            return
        if self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
            return
        if self.rank[rootY] > self.rank[rootX]:
            self.parent[rootY] = rootX
            return
        self.parent[rootX] = rootY
        self.rank[rootX] += 1
        return

    def getcount(self): # do another path compression to get the number of elements in each connected component
        if not self.parent:
            return 0
        counter = Counter([self.find(num) for num in self.parent])
        return counter.most_common(1)[0][1]
            

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        hashmap = {}
        idx = 0
        for i, num in enumerate(nums):  # we don\'t care about duplicated numbers
            if num not in hashmap:
                hashmap[num] = idx
                idx += 1 # reassign each unique number a new index to make it easier to construct disjoint set
        uf = UnionFind(len(hashmap))
        for num in hashmap:
            i = hashmap[num]
            next = num + 1
            prev = num - 1
            if next in hashmap:
                uf.union(hashmap[next], i)
            if prev in hashmap:
                uf.union(hashmap[prev], i)
        return uf.getcount()