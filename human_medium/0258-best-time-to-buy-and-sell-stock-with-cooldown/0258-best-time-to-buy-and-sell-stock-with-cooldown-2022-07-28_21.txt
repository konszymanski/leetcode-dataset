# Divide the stocks buying and selling activity in to 4 states
# If stocks are bought, there will be states - sell and hold
# If stocks are not bought, there will be states - buy and not_buy

# Here is the recursion tree I came up with:
# Using prices: [1, 2, 3] 

# Since the first level, we didn\'t buy any stock yet. States available: buy and not_buy
# max(maxProfit(0, True) - 1, maxProfit(0, False)

# The second level, we can consider sell and hold after we bought the stocks
# Remember we increase the start by 2 because we need to have cooldown after selling stocks
# Also, we can consider buy and not_buy from the side of not buying any stocks yet

# max(maxProfit(2, False) +  2, maxProfit(1,  True) , maxProfit(1, True) - 2, maxProfit(1, False))

# We reach the time when the stock price is 3 which is similar to the above level


class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        @functools.lru_cache(None)
        def dp(start, stock_bought):
            if start >= len(prices):
                return 0
            sell, hold, buy, not_buy = 0, 0, 0, 0
            if stock_bought:
                sell = dp(start + 2, False) + prices[start]
                hold = dp(start + 1, True)
            else:
                buy = dp(start + 1, True) - prices[start]
                not_buy = dp(start + 1, False)
            return max(sell, hold, buy, not_buy)
        return dp(0, False)