class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        # Bottom-up dynamic programming with memoization (caching)
        @lru_cache(None)
        def dp(day: int, can_buy: True) -> int:

            # Base case
            if day >= len(prices):
                return 0

            if can_buy:
                # We don\'t own any stocks. Two options:
                # 1. Don\'t buy any stocks and go to the next day (wait for a better opportunity)
                # 2. Buy stocks and go to the next day (with hope to have the best profit)
                return max(dp(day + 1, True), dp(day + 1, False) - prices[day])
            else:
                # We own stocks. Two options:
                # 1. Don\'t sell any stocks and go to the next day (maybe there is a better selling price)
                # 2. Sell the stocks and go to the day after tomorrow (cooldown tomorrow)
                return max(dp(day + 1, False), dp(day + 2, True) + prices[day])

        # Start with no stocks
        return dp(0, True)