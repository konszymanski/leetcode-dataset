class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        def partition(arr, lo, hi):
            # move pivot to the end
            mid = lo + (hi-lo) // 2
            
            # move pivot to end
            arr[mid], arr[hi] = arr[hi], arr[mid]
            pivot = arr[hi]
            
            i = lo  # i refers to store index
            j = lo
            while j < hi:
                if arr[j][0] < pivot[0]:
                    arr[i], arr[j] = arr[j], arr[i]
                    i+=1
                    j+=1
                else:
                    j+=1
            
            # now i points to an entry bigger or equal to pivot so move pivot back
            arr[i], arr[hi] = arr[hi], arr[i]
            return i
                
        def quickselect(arr, lo, hi, k):
            if lo<=hi and k: # 2 or more items in arr
                p = partition(arr, lo, hi)
                
                # check how many entries found and call recursively
                num_found = hi - p + 1 # includes p
                if num_found <= k:
                    ans.extend([key for _, key in arr[p:hi+1]])
                    quickselect(arr, lo, p-1, k-num_found)
                else:
                    quickselect(arr, p+1, hi, k)
                
        if not nums:
            return []
       
        frequencies = collections.Counter(nums)
        
        if len(frequencies) == k:
            return frequencies.keys()
        
        arr = [(v, k) for k, v in frequencies.items()]    
        ans = []
        
        quickselect(arr, 0, len(arr)-1, k)
        return ans