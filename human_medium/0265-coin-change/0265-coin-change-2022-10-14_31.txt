class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        return self.dynamicProgramming(coins,amount)
    def dynamicProgramming(self, coins: List[int], amount: int) -> int:    
        dp = [amount + 1] * (amount + 1)
        dp[0] = 0
        
        for am in range(1,amount + 1):
            for coin in coins:
                if am - coin >= 0:
                    dp[am] = min(dp[am],dp[am - coin] + 1)
        return dp[amount] if dp[amount] < amount + 1 else -1
    
    def memoization(self, coins: List[int], amount: int) -> int:
        dp = {}
        
        def dfs(amount):
            if amount in dp:
                return dp[amount]
            if amount == 0:
                return 0
            
            res = math.inf
            for coin in coins:
                if (amount - coin) >= 0:
                    res = min(res,1 + dfs(amount - coin))
            dp[amount] = res
            return res
        
        res = dfs(amount)
        return res if res != math.inf else -1