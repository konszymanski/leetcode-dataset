class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0 or not coins: return 0
        
        # this dp will hold the number of coins
        # required for every amount from 0..amount
        dp = [float(\'inf\')] * (amount+1)
        
        # to have a sum of zero
        # we don\'t need any coins i.e 0
        dp[0] = 0
        
        # brute force, we\'ll calculate
        # the coins needed for every amount
        # starting from 1 since we\'ve calculated 0
        for a in range(1, amount+1):
            # for every amount, we\'ll
            # try to form coins with every
            # available coin
            for c in coins:
                # if the current amount is less
                # than the current coin, you can\'t
                # make that amount with this coin
                # so skip it. i.e. if a = 2 and coin = 5
                # you should not bother computing anything here
                if a-c >= 0:
                    # otherwise, you check the min
                    # of the num(coins) for current amount
                    # and the 1 plus the coins required
                    # by amount-c i.e. to make the amount 0
                    # for e.g. if amount = 7 and coin = 3,
                    # we can say the coins needed to make 7
                    # would be the coin of denomination 4 (+1) and
                    # the number of coins taken to reach 3
                    # => 1 + dp[3] so that we can easily reach the sum i.e 7
                    dp[a] = min(dp[a], dp[a-c]+1)
            
        # we need to return -1 if we weren\'t able to find
        # an answer i.e. no updates were made and the amount
        # still has the initial value we had set i.e float(\'inf\')
        return dp[amount] if dp[amount] != float(\'inf\') else -1