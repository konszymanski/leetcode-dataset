"""
322. Coin Change


For each coin, we have two decisions (0-1 knapsack)
- pick it - pay cost 1
- don\'t pick it - pay cost 0, 

we want to accumulate the number of coins and minimize
the total amount to reach a certain value amount.

we can try all coins for each quantity amount.
for each coin, we can pick the minimum 

approaches:
top down/bottom up are dual of each other.
bfs - find shortest path to reach the amount, each level in 
the search tree denotes the number of coins.

complexity:
O(amount * n) spacetime


Note, BFS is fastest since it can early return!!

"""

class SolutionDFS:
    def coinChange(self, coins: List[int], amount: int) -> int:
        n = len(coins)
        
        @cache
        def dfs(amount):
            min_coins = inf
            
            # base case - found our target
            if amount == 0:
                return 0
            if amount < 0:
                return min_coins # invalid
            
            for c in coins:
                proposed = amount - c
                # the two options:
                # pick min_coins, which means we didn\'t pick this coin
                # pick 1+dfs(proposed), which means we picked the coin,
                # paying for 1, along with the cost of the subproblems
                min_coins = min(min_coins, 1 + dfs(proposed))

            return min_coins
            
        
        v =  dfs(amount)
        return v if not v==inf else -1
        

class SolutionBottomUp:
    def coinChange(self, coins: List[int], amount: int) -> int:
        default = amount + 1
        dp = [default] * (amount + 1) # Int -> Int    amount -> num coins
        dp[0] = 0
        
        # populate for every amount from 1 to amount inclusive.
        for a in range(1, amount+1):
            for c in coins:
                proposed = a - c
                if proposed >= 0:
                    dp[a] = min(dp[a], 1+dp[proposed])
             
        if dp[amount] == default:
            return -1
        return dp[amount]
            
class SolutionBFS:        
    def coinChange(self, coins: List[int], amount: int) -> int:
        if not amount:
            return 0

        queue = deque([amount])
        visited = set([amount])
        num_coins = 0

        while queue:
            # each level of the decision tree denotes
            # a certain number of coins. 
            num_coins += 1

            size = len(queue)

            for i in range(size):
                amount = queue.popleft()

                for c in coins:
                    proposed = amount - c

                    # the first to reach the target must be shortest
                    if proposed == 0:
                        return num_coins

                    if proposed not in visited and proposed > 0:
                        queue.append(proposed)
                        visited.add(proposed)

        return -1
        
Solution = SolutionBFS