class DisjointSet():
    def __init__(self):
        self.parents = {}
        
    def make_set(self, node):
        if self.find(node) == node:
            self.parents[node] = node
            
    def find(self, node):
        # path compression
        if self.parents.get(node, node) != node:
            self.parents[node] = self.find(self.parents[node])
        return self.parents.get(node, node)
    
    def union(self, node_1, node_2):
        root_1, root_2 = self.find(node_1), self.find(node_2)
        if root_1 == root_2: return
        if root_1 == node_1: self.parents[root_1] = root_2
        else: self.parents[root_2] = root_1
        
class Solution:
    def lowestCommonAncestor(self, root: \'TreeNode\', p: \'TreeNode\', q: \'TreeNode\') -> \'TreeNode\':
        if not root or not p or not q: return
        ds = DisjointSet()
        # make buffer accessible from within the recursion
        buffer = {\'ancestor\': None}
        visited = set()
        def _r(node, l=0):
            if buffer[\'ancestor\']: return
            # explore children
            if node.left: _r(node.left, l+1); ds.union(node, node.left)
            if node.right: _r(node.right, l+1); ds.union(node, node.right)
            # add node to visited
            visited.add(node)
            # check if we have already visited p and q
            if buffer[\'ancestor\']: return
            if p in visited and q in visited:
                if ds.find(p) == ds.find(q):
                    buffer[\'ancestor\'] = node; return
        _r(root)
        return buffer[\'ancestor\']