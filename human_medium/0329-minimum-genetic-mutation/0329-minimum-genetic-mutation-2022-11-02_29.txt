class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        if end not in bank:
            return 0 if (start == end) else -1

        def difference(A, B):
            c = 0
            for i in range(len(A)):
                if A[i] != B[i]:
                    c+=1
            return c

        bank += [start]
        # create the graph
        adj = collections.defaultdict(set)
        for i in range(len(bank)-1):
            for j in range(len(bank)):
                if difference(bank[i], bank[j]) == 1:
                    adj[bank[i]].add(bank[j])
                    adj[bank[j]].add(bank[i])
        
        best = float(\'inf\')
        seen = {}
        def dfs(node, count):
            nonlocal end, best
            if node==end:
                best = min(best, count)
            seen[node] = count
            
            for nei in adj[node]:
                if nei not in seen or seen[nei] > count+1: # should explore it IF current path to nei is SHORTER. (note that if we used BFS, this second condition would be true by nature)
                    dfs(nei, count+1)
        
        dfs(start, 0)
        return best if (best != float(\'inf\')) else -1