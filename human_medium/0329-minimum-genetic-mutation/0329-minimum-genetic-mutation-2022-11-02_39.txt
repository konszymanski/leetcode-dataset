def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        #Use BFS since we want shallowest solution
        q = deque()
        seen = set()
        
        #Helper function to get moves from our current state we can do this since max length of bank is 10
        def getValidMoves(s):
            res = []
            for w in bank:
                if sum ( s[i] != w[i] for i in range(len(s)) ) == 1:
                    res.append(w)
            return res
        
        validMoves = getValidMoves(start)
        for m in validMoves:
            q.append((m, 1))
            seen.add(m)
        
        while q:
            #pop the current state of our mutation and the amount of moves it takes us to get there
            curMutation, curMutationMoveCount = q.popleft()
            if curMutation == end:
                return curMutationMoveCount
            #otherwise add potential moves from this state only if we haven\'t already seen the mutation
            else:
                for m in getValidMoves(curMutation):
                    if m not in seen:
                        #Increment move count since we\'re making a new move
                        q.append((m, curMutationMoveCount + 1))
                        seen.add(m)
                        
        return -1