class Solution:
    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        def compare(gene,startGene):
          simToCurr = 0
          for i in range(len(gene)):
            if gene[i] != startGene[i]:
              simToCurr +=1
          return simToCurr

        moves = 0
		
        while startGene != endGene:
          possible = []
          for gene in bank:
            if compare(gene,startGene) == 1:
              possible.append(gene)

          highest = 0
          if len(possible) <1:
            return -1
          
          for i in range(len(possible)):
            if compare(possible[i],endGene) < compare(possible[highest],endGene):
              highest=i

          startGene = possible[highest]
          bank.remove(possible[highest])
          moves+=1
          
        return moves