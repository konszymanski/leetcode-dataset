def minMutation(self, start: str, end: str, bank: List[str]) -> int:
	# queue to keep track of genes we are looking at and how many mutations it took to get there
	q = collections.deque([(start,0)]) 

	while q: # while there are elements in the queue
		gene, mutations = q.popleft() # get the gene and how many mutations it took to get there
		if gene == end: # if we reached the end
			return mutations # return the number of mutations (since it\'s BFS, the first time we get here will be the best)
		i = 0 # index to iterate through bank
		while i < len(bank): # while in-bounds
			bankgene = bank[i] # gene from bank
			if sum([x == y for (x,y) in zip(gene,bankgene)]) == 7: # if the current gene and this one share 7 characters (we can mutate from gene to bankgene)
				q.append((bankgene, mutations+1)) # add this bankgene to our queue, the number of mutations to get here is 1 more than to get to gene
				bank.remove(bankgene) # remove bankgene from bank since we have now found the fastest way to get to it
				# since we removed an element from bank, we don\'t move i forward
			else:
				i += 1 # move i forward to the next element

	return -1 # no way to get to the end