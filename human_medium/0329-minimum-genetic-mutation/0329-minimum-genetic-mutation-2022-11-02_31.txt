class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        """
            . single digit change must exist in bank for mutate-a to b. find minimum steps to reach end
            
            . ok firstly lets findd out the letters that are different. then we can dp. for i in banks where that position has an required letter, use it and find min way to get all settled
                or instead of dp, use BFS.. since bfs also gives shortest distance and all of it are nodes
        """

        g = defaultdict(set)
        
        def is_one_diff(one, two):
            one_diff = False
            for i in range(len(one)):
                if one[i] == two[i]: continue
                elif one_diff == False: one_diff = True
                else: return False
            
            if one_diff == True:
                return True 
            else:
                return False
        
        
        n = len(bank)
        for j in range(n):
            if is_one_diff(start, bank[j]) == True:
                g[start].add(bank[j])
                g[bank[j]].add(start)
        
        for i in range(n):
            for j in range(n):

                if is_one_diff(bank[i], bank[j]) == True:
                    g[bank[i]].add(bank[j])
                    g[bank[j]].add(bank[i])
        
        
        q = [(start, 0)] # word , distance
        seen = set()
        
        while q:
            top, d = q.pop(0)
            if top == end:
                return d
            
            if top in seen:
                continue
            
            seen.add(top)
            
            for other in g[top]:
                q.append((other, d + 1))
        
        return -1