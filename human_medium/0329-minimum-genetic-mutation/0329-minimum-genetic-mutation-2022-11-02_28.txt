class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:

        def distanceOne(gene1: str, gene2: str) -> bool:
            differenceFound = False
            for char1, char2 in zip(gene1, gene2):
                if char1 != char2:
                    if not differenceFound:
                        differenceFound = True
                    else:
                        return False
            return differenceFound
        
        def possibleNext(gene: str, visited: int) -> (str, int):
            for i, bankGene in enumerate(bank):
                if not (1 << i) & visited and distanceOne(gene, bankGene):
                    yield (bankGene, visited | (1 << i))

        geneStack = collections.deque(possibleNext(start, 0))
        while geneStack:
            gene, visited = geneStack.popleft()
            if gene == end:
                return bin(visited)[2:].count("1")
            geneStack.extend(possibleNext(gene, visited))

        return -1