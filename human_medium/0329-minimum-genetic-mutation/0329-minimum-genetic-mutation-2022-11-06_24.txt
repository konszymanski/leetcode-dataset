class Solution:
    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        #searching in set is faster than in array
        bank = set(bank)

        #since each valid gene should be in bank
        #so if endgene is not in the bank hence we cannot acheive it ever
        if endGene not in bank:
            return -1
        
        visited = set()
        visited.add(startGene)
        q=[[startGene,0]]
        while len(q)!=0:            
            for i in range(len(q)):
                node,level = q.pop(0)
                #we check each valid gene and if it\'s equal to endgene then return its level
                if node == endGene:
                    return level
                
                #make all the 32 combinations for the node
                for i in range(len(node)):
                    for letter in \'ACGT\':
                        new_gene = node[:i] + letter + node[i+1:]
                        if new_gene not in visited and new_gene in bank:
                            q.append([new_gene,level+1])
                            visited.add(new_gene)
        return -1