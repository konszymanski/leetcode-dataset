class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
		# it\'s impossible to mutate to end when end is not in bank
        if end not in bank: return -1
        
		# make sure our graph (adjacency list) contains start
        arr = list(set(bank + [start]))
        
		# construct graph
        graph = defaultdict(list)
        for i in range(len(arr)):
            for j in range(i+1, len(arr)):
                u, v = arr[i], arr[j]
                cnt = 0
                for c1, c2 in zip(u, v):
                    if c1 != c2: cnt += 1
                if cnt == 1:
                    graph[u].append(v)
                    graph[v].append(u)
        
		# BFS template
        visited = set(start)
        queue = collections.deque([start])
        mutations = 0
        while queue:
            size = len(queue)
            for _ in range(size):
                node = queue.popleft()
                
                if node == end:
                    return mutations
                
                for nei in graph[node]:
                    if nei not in visited:
                        visited.add(nei)
                        queue.append(nei)
            mutations += 1
        
        return -1