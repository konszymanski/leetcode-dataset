class Solution:
    def minMutation(self, start: str, end: str, bank: List[str]) -> int:
        def canMutate(gene1, gene2):
            mutationsNeeded = 0
            for i in range(len(gene1)):
                if gene1[i] != gene2[i]:
                    mutationsNeeded += 1
            return mutationsNeeded
        
        mut_count = 0
        depth = 0
        seen = set()
        mutate_q = [(start, 0)] #Each mutation keeps track of how "deep" it is with a tuple.
        while len(mutate_q) > 0:
            current_mut = mutate_q[0]
            if canMutate(current_mut[0], end) == 0:
                return current_mut[1] #Return the depth of the current mutation if it matches the end mutation.

            for mut in bank:
                if canMutate(current_mut[0], mut) == 1 and mut not in seen:
                    mutate_q.append((mut, current_mut[1] + 1)) #Add one to depth every time we append to the queue.
                    seen.add(mut)
            mutate_q.pop(0)

        return -1