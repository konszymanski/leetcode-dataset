class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        // use PQ, the element is self-defined MatrixCell
        PriorityQueue<MatrixCell> pq = new PriorityQueue<>((a,b)->(a.val-b.val));
        int row = matrix.length, col = matrix[0].length;
        // since each row is sorted, the first number of each row is the smallest among its specific row
        // we push them into pq
        for (int r = 0; r < row; r++) {
            pq.offer(new MatrixCell(r, 0, matrix[r][0]));
        }

        // since it is a min heap, each time we poll a number
        // it will be the smallest among the heap
        // when we poll a number, we add a new number from the same row of this number
        // in this way, we poll() k-1 numbers, then the heap top is the Kth smallest 
        for (int i = 0; i < k-1; i++) {
            // poll a number
            MatrixCell cell = pq.poll();
            // add a number, if there are still numbers unused in that row
            if (cell.col != col-1) {
                int nextNum = matrix[cell.row][cell.col+1];
                pq.offer(new MatrixCell(cell.row, cell.col+1, nextNum));
            }

        }
        return pq.peek().val;
    }
}


// This is to save the position infomation of each cell in the pq
class MatrixCell {
    int row;
    int col;
    int val;
    MatrixCell(int row,int col,int val) {
        this.row = row;
        this.col = col;
        this.val = val;
    }
}