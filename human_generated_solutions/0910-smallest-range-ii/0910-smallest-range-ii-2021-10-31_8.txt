# Approach 1: 
# Time complexity:  O(n)
# Space complexity: O(1)
# ----------------
# The idea is to minimize the difference between max and min:
    # Max value tends to become smaller
    # Min value tends to become larger
# Cause A[i] < A[i + 1], to minimize the difference:
    # make smaller larger: A[i] + K, A[0] + K
    # make larger smaller: A[i + 1] - K, A[-1] - K
# Update the Max and Min:
    # max: max(A[-1] - K, A[i] + K)
    # min: min(A[0] + K, A[i + 1] - K)
# Update the result:
    # res = max - min
# We know, A - B = (A + K) - (B + K),
    # res = max - min = max(A[-1] - K, A[i] + K) - min(A[0] + K, A[i + 1] - K)
    # res = max - min = max(A[-1], A[i] + 2 * K) - min(A[0] + 2 * K, A[i + 1])
# ----------------

def smallestRangeII(nums, k):
    """
    :type nums: List[int]
    :type k: int
    :rtype: int
    """
    nums.sort()
    mn, mx = nums[0], nums[-1]
    res = mx - mn
    for i in range(len(nums)-1):
        if nums[i] < nums[i+1]:
            mx = max(nums[-1] - k, nums[i]   + k)
            mn = min(nums[0]  + k, nums[i+1] - k)
            res = min(res, mx - mn)

    return res