class DSU:
    def __init__(self, N):
        self.parent = [i for i in range(N)]
        self.size = [1] * N
        self.components = N

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, a, b):
        ua = self.find(a)
        ub = self.find(b)
        if ua == ub:
            return False

        if self.size[ua] < self.size[ub]:
            ua, ub = ub, ua

        self.parent[ub] = ua
        self.size[ua] += self.size[ub]
        self.size[ub] = self.size[ua]
        self.components -= 1
        return True


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        N = len(graph)
        uf = DSU(N)
        for i in range(N):
            for j in range(N):
                if i != j and graph[i][j]:
                    uf.union(i, j)
        setSizes = Counter(uf.find(node) for node in uf.parent)
        infectedSizes = Counter(uf.find(node) for node in initial)
        ans = min(initial)
        temp = 0
        for i in initial:
            if infectedSizes[uf.find(i)] == 1:
                if setSizes[uf.find(i)] > temp:
                    temp = setSizes[uf.find(i)]
                    ans = i
                elif setSizes[uf.find(i)] == temp:
                    ans = min(ans, i)
        return ans
    # Time: O((N^2 + M) * \u03B1(N)) where N is the number of nodes in the graph and M the length of initial
    # Space: O(N)