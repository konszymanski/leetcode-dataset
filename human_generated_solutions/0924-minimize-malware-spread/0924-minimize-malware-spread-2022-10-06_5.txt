def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:        
        n = len(graph)
        initial = set(initial)
        # [parent, initialCount, smallestInitial, affected]
        parents = [[node,1,node,1] if node in initial else [node,0,inf,0] for node in range(n)]
        size = [1]*n

        def find(i):
            if parents[i][0] != i:
                parents[i][0] = find(parents[i][0])
            return parents[i][0]

        #undirected graph, i.e graph[i][j] == graph[j][i] == symmetrical matrix
        for i in range(n):
            for j in range(i+1, n):
                if graph[i][j]:
                    parent_i = find(i); parent_j = find(j)
                    if parent_i != parent_j:
                        #both affected if atleast one is affected
                        if parents[parent_i][-1] or parents[parent_j][-1]:
                            parents[parent_i][-1] = parents[parent_j][-1] = 1
                            #increase the count of initally affected nodes
                            parents[parent_i][1] += parents[parent_j][1]
                            parents[parent_j][1] = parents[parent_i][1]
                            #update the smallestIndexInitial
                            parents[parent_i][2] = parents[parent_j][2] = min(parents[parent_i][2],parents[parent_j][2])
                        
                        #union
                        parents[parent_j][0] = parent_i
                        size[parent_i] += size[parent_j]
        
        ans = inf; c_max_size = -1
        for i in range(n):
            #we only care about parents because they represent the whole component
            if i == parents[i][0] and parents[i][-1] and parents[i][1]==1:
                if c_max_size < size[i]:
                    c_max_size = size[i]
                    ans = parents[i][2]
                elif c_max_size == size[i]:
                    ans = min(ans, parents[i][2])
        
        #edge case, sometimes M(initial) will never change.
        #then just return the smallest element from initial
        if ans == inf: ans = min(initial)

        return ans