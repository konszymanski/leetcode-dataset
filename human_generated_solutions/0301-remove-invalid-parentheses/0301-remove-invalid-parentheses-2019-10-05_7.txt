class Solution(object):
    def removeInvalidParentheses(self, s):
        if s == "":
            return [""]
        
        # check the initial state of \'s\'. If either \'(\' or \')\' is in excess.
        left = right = 0
        for paren in s:
            if paren == \'(\':
                left += 1
            elif paren == \')\' and left > 0:
                left -= 1
            elif paren == \')\' and left == 0:
                right += 1
        
        #Method 1: BFS
        self.result = []
        self.visited = set()
        self._BFS(s, left, right)
        
        #Method 2: DFS
        self.result = []
        self.visited = set()
        self._DFS(s, 0, left, right)
        
        if self.result == []:
            return [""]
        
        return self.result

    def _DFS(self, s, index, left, right):
        self.visited.add(s)
        # only if the s is balanced check if it is also valid.
        if left == 0 and right == 0:
            if self._isValid(s):
                self.result.append(s)
        
        for i in range(index, len(s)):
            # if it is any other char ignore.
            if s[i] != \'(\' and s[i] != \')\':
                continue
            
            # if left == 0 then removing \'(\' will only cause imbalance. Hence, skip.
            if s[i] == \'(\' and left == 0:
                continue
            
            # if right == 0 then removing \')\' will only cause imbalance. Hence, skip.
            if s[i] == \')\' and right == 0:
                continue
            
            nxt = s[:i] + s[i+1:]
            if nxt not in self.visited:
                self._DFS(nxt, i, left - (s[i]==\'(\'), right - (s[i]==\')\'))
        
        
    def _BFS(self, s, left, right):
        BFSQueue, result = [(s, left, right)], []        
        minFound = False 
        
        while BFSQueue:
            s, l, r = BFSQueue.pop(0) 
            
            # only if the s is balanced check if it is also valid.
            if l == 0 and r == 0:
                if self._isValid(s):
                    result.append(s)
                    minFound = True
            
            #Once a valid expression is found, no need to do any further removals. 
			#Just check for whatever is remaining in the queue
            if minFound:
                continue
            
            for i in range(len(s)):
                # if it is any other char ignore.
                if s[i] != \'(\' and s[i] != \')\':
                    continue
                
                # if l == 0 then removing \'(\' will only cause imbalance. Hence, skip.
                if s[i] == \'(\' and l == 0:
                    continue
                    
                # if r == 0 then removing \')\' will only cause imbalance. Hence, skip.
                if s[i] == \')\' and r == 0:
                    continue
                    
                nxt = s[:i] + s[i+1:]
                if nxt not in self.visited:
                    self.visited.add(nxt)
                    BFSQueue.append( (nxt, l - (s[i]==\'(\'), r - (s[i]==\')\')) )
        
        self.result = result

        
    def _isValid(self, paren):
        parenCount = 0
        for p in paren:
            if p == \'(\':
                parenCount += 1
            elif p == \')\':
                parenCount -= 1
            if parenCount < 0:
                return False
        return parenCount == 0