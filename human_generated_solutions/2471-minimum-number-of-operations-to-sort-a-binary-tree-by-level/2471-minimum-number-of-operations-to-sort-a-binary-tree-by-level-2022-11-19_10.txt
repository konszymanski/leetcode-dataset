class Solution:
    def minimumOperations(self, root: Optional[TreeNode]) -> int:
        return sum([self.minimum_swaps(level) for level in self.bfs_levels(root)])

    def bfs_levels(self, root: Optional[TreeNode]) -> list[list[int]]:
        nodes, levels, index = [root], [0], 0

        while index != len(nodes):
            for child in nodes[index].left, nodes[index].right:
                if child:
                    nodes.append(child)
                    levels.append(levels[index] + 1)
            index += 1

        values = [[] for _ in range(levels[-1] + 1)]
        for index in range(len(nodes)):
            values[levels[index]].append(nodes[index].val)

        return values

    def minimum_swaps(self, array: list[int]) -> int:
        sorted_indexes = sorted(range(len(array)), key=array.__getitem__)
        return len(array) - sum(self.has_cycle(sorted_indexes, index) for index in range(len(array)))

    def has_cycle(self, sorted_indexes: list[int], index: int) -> bool:
        had_cycle = False
        while sorted_indexes[index] != -1:
            sorted_indexes[index], next_index = -1, sorted_indexes[index]
            index, had_cycle = next_index, True
        return had_cycle