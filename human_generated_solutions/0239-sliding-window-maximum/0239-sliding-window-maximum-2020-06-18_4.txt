class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        ## RC ##
        ## APPROACH : DEQUE ##
        """
            ## LOGIC ##
            1. For the First k numbers we can directly find maximum and store, but the when the window slides by one position, the first element is removed. 
                What if the first number is the maximum of 0 to K ? How do we know the second maximum when first element is removed ? ( consider this example: [5, 2, 3, -1] and k = 3 ans = [5, 3] )
                So, For that we need to maintain some storage, here we use deque.
            2. Our Deque will always have the maximum at the start and we append small elements next to it. 
                ( if deque(for now, say we have numbers in it) is [4,1,0] and incoming curr num is 2, pop all nums smaller from backside i.e deque will be [4, 2] )
            3. And when the window slides, we remove all the numbers from front of deque if they donot fall under this window size.

            Example : [1,3,1,2,0,5] 3
            deque([0])              [1]
            deque([1])              [1, 3]
            deque([1, 2])           [1, 3, 3]
            deque([1, 3])           [1, 3, 3, 3]
            deque([3, 4])           [1, 3, 3, 3, 2]
            deque([5])              [1, 3, 3, 3, 2, 5]

            ## TIME COMPLEXITY : O(N) ##
            ## SPACE COMPLEXITY : O(k) ##
        """
        deque = collections.deque()
        res = []
        for i, num in enumerate(nums):
            while(deque and nums[deque[-1]] < num):
                deque.pop()     # 2
            if(deque and i - deque[0] >= k):
                deque.popleft() # 3
            deque.append(i)
            res.append(nums[deque[0]])
            # print(deque, res)
        return res[k-1:]