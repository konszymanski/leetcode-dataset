def orangesRotting(self, grid: List[List[int]]) -> int:
	# One pass to fill up initial fresh and rotten
	fresh = set()
	unvisited_rotten = set()
	for i, row in enumerate(grid):
		for j, cell in enumerate(row):
			if cell==2:
				unvisited_rotten.add((i, j))
			elif cell: # not 0 or 2
				fresh.add((i, j))
				
	minutes = 0
	# While there\'s still fresh oranges and unexplored rotten oranges
	while fresh and unvisited_rotten:
		# Fresh oranges adjacent to any last rotten become rotten now 
		unvisited_rotten = set().union(*[fresh & {(i, j+1), (i+1, j), (i-1, j), (i, j-1)} for i, j in unvisited_rotten])
		fresh -= unvisited_rotten

		minutes += 1

	# Impossible if all rotten were exhausted but fresh still left, otherwise it took minutes time
	return -1 if fresh else minutes