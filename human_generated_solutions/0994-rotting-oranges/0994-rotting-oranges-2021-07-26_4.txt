from collections import deque
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        
        """
        Step 1: recogonise this is a BFS problem with 4 direction finding neighbor
        Step 2: before we go into BFS, we need to do some preparation steps
        Step 3: run BFS
        
        When should we run BFS? It has 2 cases:
        One is after finding all the initial elements,
        the other is after finding exactly one initial element
        In this question, we should note that if we have 2 rotten oranges 
        in the beginning, they will infect at the same time. 
		
		So we can not write BFS after finding exactly one rotten orange, 
        we need to put them into the same level at the initial.

        
        # Step 1: Some standard preparation work
        # (1) Define a row and col. 
        row = len(grid)
        col = len(grid[0])
        
        # In this question, when do we return the result?
        # What is the judging standard for finishing?
        # That is, if all the fresh oranges disappear, it means finishing
        # So we need to set a count for fresh orange
        # Do we need to also set a count for rotten orange? 
        It seems not necessary, since it will not act any role 
        on the question
        fresh_orange = 0
        
        # (2) Define the queue and put the initial coordinate into the queue.
        # Here is also depended on the problem on if we need to put coordinate 
        into the queue
        # or the object itself into the queue. For example, should we put 
        grid[0][0] or (0, 0) into the queue? I can not say definitely on 
        the standard, but if we meet an array problem, we usually use 
        coordinate.
        # This is the standard process to create a queue
        queue = deque()
        
        # To put the initial elements into the queue, we need to decide 
        whether we let the BFS be right after the first one element, or we 
        choose all the initial coordinates into the queue
        # First we choose all the initial coordinates into the queue
        for i in range(row):
            for j in range(col):
                # put what into the queue first? that is, the rotten one, grid[i][j] = 2
                if grid[i][j] == 2:
                    queue.append((i, j))
                # also we update the number of fresh orange
                elif grid[i][j] == 1:
                    fresh_orange += 1
        
        # Now it is time for BFS. The rule is first in, first out.
        # Our queue now has all the rotten oranges. For example, if 1, 3 is the rotten orange
        # the queue now is
        # ------------------------------------------------
        # 1  3 |
        # ------------------------------------------------
        # Now we do BFS to take out the 1st element
        
        count = 0
        # When is the situation to go into this BFS?
        # first, we need to assure our queue is not empty, that is, it must have rotten orange.
        # if rotten orange is 0, then it will not go into this while loop.
        # and when all the oranges are rotten, also not go into this while loop.
        while queue and fresh_orange > 0:
            # we need to take out the 1st element
            # how to do this? a standard process is below
            # len(queue) = 2 now, range(2) is 0, 1
            # this shows that, in this level, it will traverse all the elements in this level
            # while control the traversal from level to level
            for _ in range(len(queue)):
                x, y = queue.popleft()
            
                # after finding the first element, we need to think if we should judge something
                # the judge is depending on the question requirement
                # In this question, looks nothing needs to be judged. So we safely find the neighbor
                # a standard process for finding the neighbor is regularly 4 directions below
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    
                    # the candidate neighbor is here
                    # In other question, we may find the neighbor for example like this
                    # node.left; 0 -> 9, 1; a -> z, b... depending on the question
                    xx, yy = x + dx, y + dy
                    
                    # we first consider if this neighbor is out of the border
                    if xx < 0 or xx == row or yy < 0 or yy == col:
                        continue
                    
                    # we also need to consider, if this neighbor is fresh or empty, we continue
                    # note, some problems need us to judge on the 1st element, not neighbor
                    # so judging the 1st element or its neighbor, depending on the question
                    # grid[xx][yy] == 0 assures we skip the empty cell
                    # grid[xx][yy] == 2 assures we skip the rotten orange. This rotten orange
                    # may already exist, or it is the one that we marked before
                    # If we do not skip, then the rotten orange that we mark before will
                    # be added again into the queue. That is chaotic
                    if grid[xx][yy] == 0 or grid[xx][yy] == 2:
                        continue
                        
                    # so the left coordinates are the expected fresh orange
                    # we have found our expected neighbor, now we put them into the queue
                    queue.append((xx, yy))
                    
                    # we mark the neighbor as rotten
                    grid[xx][yy] = 2
                    
                    # we subtract our fresh orange with -1
                    fresh_orange -= 1
                
                    # after this cycle of finding, the queue will be
                    # ------------------------------------------------
                    #   3  |  2  4  |
                    # ------------------------------------------------
                    
                # this level of for loop to connitue to execute 3, after that, the queue will be
                # ------------------------------------------------
                #      |  2  4  |
                # ------------------------------------------------
            
            # while loop assures we do this level by level
            # ------------------------------------------------
            #      |  2  4  |
            # ------------------------------------------------
        
            # after finishing each level, we count + 1
            # here if we write count + 1 in the beginning of the while loop  
            # the number will not right
            # the difference is that, we count before finding neighbor or after finding neighbor
            # In this case, when we find a neighbor, the minute will add 1, so we write in the end
            count += 1
            
        # Finally, we show the final result
        # Note, this is a simple writing method
        return count if fresh_orange == 0 else -1
        
        # if we write in standard, it will be
        """
        if fresh_orange == 0:
            return count
        else:
            return -1
        """

        
"""
The whole process is: ( note I assume rotten is 1, 3 initially, not the example 1)
------------------------------------------------
1  3  |
------------------------------------------------
------------------------------------------------
   3  |  2  4  |
------------------------------------------------
------------------------------------------------
      |  2  4  |
------------------------------------------------
------------------------------------------------
      |     4  |  5
------------------------------------------------
------------------------------------------------
      |        |  5  |
------------------------------------------------
------------------------------------------------
      |        |     |  8  |
------------------------------------------------
------------------------------------------------
      |        |     |     |  9
------------------------------------------------
the level is 
1  3
2  4
5
8
9
"""