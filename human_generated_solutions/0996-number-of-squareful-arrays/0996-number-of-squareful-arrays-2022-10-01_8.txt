class Solution:
    def numSquarefulPerms(self, nums: List[int]) -> int:
        def isPerfectSquare(n): 
            """Check if n is a perfect square."""
            return int(n ** 0.5) == n ** 0.5
        
        @lru_cache(None)
        def check(nums, length, tol=2):
            """
            If there are tol or more adjacent pairs that don\'t sum to a 
            perfect square, return False, otherwise return True.
            """
            count = 0
            for i in range(length - 1):
                if not isPerfectSquare(nums[i] + nums[i + 1]): count += 1
                if count == tol: return False
            return True
        
        n, seen, res, q = len(nums), set(), set(), deque([((nums[0],), 1)])
        while q:
            cur, i = q.popleft()
            if i == n:
                if check(cur, i, 1): res.add(cur)
                continue
            
            # Assume that cur = (4, 3), next = 5, for (5, 4, 3), (4, 5, 3)
            # (4, 3, 5), add whichever has at most one adjacent pair that 
            # doesn\'t sum to a perfect square into queue since such perm
            # is possible to be valid after inserting a number.
            for p in (cur[:j] + (nums[i],) + cur[j:] for j in range(i + 1)):
                if p not in seen and check(p, i + 1): 
                    seen.add(p) # exclude duplicates
                    q.append((p, i + 1))

        return len(res)