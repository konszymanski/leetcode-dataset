class UnionFind:
    def __init__(self, n): 
        self.parent = list(range(n))
        self.rank = [1] * n 
        
    def find(self, p): 
        if self.parent[p] != p: 
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]
    
    def union(self, p, q): 
        prt, qrt = self.find(p), self.find(q)
        if prt == qrt: return False 
        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt
        self.parent[prt] = qrt
        self.rank[qrt] += self.rank[prt] 
        return True 
    

class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        n = len(grid) # dimension 
        uf = UnionFind(n*n)
        for i in range(n):
            for j in range(n): 
                if grid[i][j]: 
                    for (ii, jj) in (i-1, j), (i, j-1): 
                        if 0 <= ii < n and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)
        
        freq = defaultdict(int)
        for i in range(n*n): freq[uf.find(i)] += 1
        
        ans = 0 
        for i in range(n): 
            for j in range(n): 
                if grid[i][j]: ans = max(ans, freq[uf.find(i*n+j)])
                else: 
                    cand = 1
                    seen = set()
                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): 
                        if 0 <= ii < n and 0 <= jj < n: 
                            if grid[ii][jj]: 
                                key = uf.find(ii*n + jj)
                                if key not in seen: 
                                    seen.add(key)
                                    cand += freq[key]
                    ans = max(ans, cand)
        return ans