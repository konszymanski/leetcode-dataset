class DisjointSet():
    def __init__(self, n):
        self.rank = [0] * (n + 1)
        self.parent = [i for i in range(n + 1)]
        self.size = [1] * (n + 1)

    def find_parent(self, node):
        if node == self.parent[node]:
            return node  # ultimate parent
        self.parent[node] = self.find_parent(self.parent[node])
        return self.parent[node]

    def unionBySize(self, u, v):
        u = self.find_parent(u)
        v = self.find_parent(v)
        if u == v: return
        if self.size[u] < self.size[v]:
            self.parent[u] = v
            self.size[v] += self.size[u]
        else:
            self.parent[v] = u
            self.size[u] += self.size[v]

class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        n = len(grid)
        ds = DisjointSet(n * n)
        # first step is connecting the components
        delrow = [1, 0, -1, 0]
        delcol = [0, 1, 0, -1]
        for row in range(n):
            for col in range(n):
                if grid[row][col] == 0:
                    continue
                for ind in range(4):
                    nrow = row + delrow[ind]
                    ncol = col + delcol[ind]
                    if nrow >= 0 and nrow < n and ncol >= 0 and ncol < n \\
                        and grid[nrow][ncol] == 1:
                            nodeNo = row * n + col
                            adjNodeNo = nrow * n + ncol
                            ds.unionBySize(nodeNo, adjNodeNo)
        
        # making 0 -> 1
        sizeOflargestIsland = 0
        for row in range(n):
            for col in range(n):
                if grid[row][col] == 1:
                    continue
                # storing componenets
                setOfComponenents = set()
                for ind in range(4):
                    nrow = row + delrow[ind]
                    ncol = col + delcol[ind]
                    if nrow >= 0 and nrow < n and ncol >= 0 and ncol < n \\
                        and grid[nrow][ncol] == 1:
                            adjNodeNo = nrow * n + ncol
                            setOfComponenents.add(ds.find_parent(adjNodeNo))
                
                sizeOfIsland = 0
                for it in setOfComponenents:
                    sizeOfIsland += ds.size[it]
                sizeOflargestIsland = max(sizeOfIsland + 1, sizeOflargestIsland)

        sizeOflargestIsland = max(sizeOflargestIsland, ds.size[ds.find_parent(n*n-1)])

        return sizeOflargestIsland