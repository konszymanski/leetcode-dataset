from typing import Tuple, Iterator

class Solution:
    def minCost(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        # Iterate over the neighborhood of a position in the grid.
        # Only neighbors within the grid boundarys are yielded.
        # The cost to visit the neighbor is 0 if the current positions
        # sign points to the neighbor. Otherwise it is 1.
        def neighborhood(y: int, x: int) -> Iterator[Tuple[int, int, int]]:
            if x + 1 < n:
                yield y, x + 1, int(grid[y][x] != 1)
            if x > 0:
                yield y, x - 1, int(grid[y][x] != 2)
            if y + 1 < m:
                yield y + 1, x, int(grid[y][x] != 3)
            if y > 0:
                yield y - 1, x, int(grid[y][x] != 4)

        # The initial cost to visit a node is infinity.
        # Only the start node can be reached with a cost of 0.
        min_cost = collections.defaultdict(lambda: math.inf, {(0, 0): 0})
        queue = collections.deque([(0, 0, 0)])

        while queue:
            cost, y, x = queue.popleft()

            # We can skip queue entries if we have already found a more
            # efficient path to their position.
            if cost != min_cost[y, x]:
                continue

            # The target position has been found and we can return the cost.
            if y == m - 1 and x == n - 1:
                return cost

            # Visit the neighbors of the current position if the path over the
            # current node improves the minimum cost to reach them.
            for y2, x2, step_cost in neighborhood(y, x):
                if (cost2 := cost + step_cost) < min_cost[y2, x2]:
                    min_cost[y2, x2] = cost2

                    # Append a neighbor to the left of the queue if there is
                    # no additional step cost. Otherwise append the neighbor
                    # to the right.
                    if not step_cost:
                        queue.appendleft((cost2, y2, x2))
                    else:
                        queue.append((cost2, y2, x2))

        return 0