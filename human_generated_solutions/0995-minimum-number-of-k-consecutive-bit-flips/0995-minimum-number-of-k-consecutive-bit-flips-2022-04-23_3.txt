class Solution:
    def minKBitFlips(self, A: List[int], k: int) -> int:
        flipped = collections.deque()  # queue to store window end indexes
        flips = 0
        n = len(A)
        for i in range(n):
            if flipped and (flipped[0] < i):    # if we have crossed the window remove from queue
                flipped.popleft()
            if len(flipped)%2 == 0:  # if len of queue is even then 1 will be 1 after even flips
                if A[i] == 1:
                    continue  # so we continue
                else:
                    if (k + i -1) >= n:  # can we apply k window sized flip here?
                        return -1
                    flipped.append(k+i-1)  # if we can we store the last index of the window
                    flips += 1  # increase our flip counter
            else:
                if A[i] == 0:  # if our queue is odd sized then our 0 will be converted to 1 so we continue
                    continue
                else:  # if its a 1 then it would be flipped to 0 so we try to apply flip operation
                    if (k + i -1) >= n:  # can we apply k window sized flip here?
                        return -1
                    flipped.append(k+i-1)  # if we can we store the last index of the window
                    flips += 1  # increase our flip counter
        return flips