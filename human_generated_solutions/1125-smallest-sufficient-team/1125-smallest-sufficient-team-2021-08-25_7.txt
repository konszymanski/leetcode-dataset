class Solution:
    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
        # O(2^N) where N is len of people
        req_skills_index_map = {rs:i for i, rs in enumerate(req_skills)}
        
        people_skills_map = {}
        ignore_peep_indices = set()
        for i, i_skills in enumerate(people): 
            if len(i_skills) == 0 or i in ignore_peep_indices:
                continue
            i_skill_set = set(i_skills)

            for j, j_skills in enumerate(people):
                if i == j:
                    continue
                j_skill_set = set(j_skills)
                if j_skill_set.issubset(i_skill_set):
                    if j in people_skills_map:
                        del people_skills_map[j]
                    ignore_peep_indices.add(j)
                    
            sk = 0
            for i_skill in i_skills:
                sk |= 1<<req_skills_index_map[i_skill]
            people_skills_map[i] = sk
       
        self.memo = {}
        self.N = len(req_skills)
        
        self.teamSize = len(people)
        self.rv = None
        for i in people_skills_map.keys():
            self.dfs(i, people_skills_map, 0, 0, 1)
        
        return self.convert_to_indices(self.rv, len(people))
    
    def dfs(self, index, people_skills_map, skillset, peopleset, people_count):
        if people_count > self.teamSize:
            return
        
        peopleset = (1<<index) | peopleset
        if peopleset in self.memo:
            return
        
        skillset = skillset | people_skills_map[index]
        if skillset == (1<<self.N)-1 and people_count < self.teamSize:
            self.teamSize = people_count
            self.rv = peopleset
        
        for i in people_skills_map.keys():
            if (1<<i) & peopleset:
                continue
                
            if skillset == (skillset | people_skills_map[i]):
                continue    
            
            self.dfs(i, people_skills_map, skillset, peopleset, people_count+1)
                
        self.memo[peopleset] = None     
    
    def convert_to_indices(self, peopleset, M):   
        result = []

        for i in range(M):
            if (1<<i) & peopleset:
                result.append(i)
        return result