class Solution:
    
    ## Quick Union Find
	## Data Structure for quickly getting connected components of a graph
    ## Guarantees log(n) time to get_component_id, join, is_connected, get_size
    class UnionFind:
        
        def __init__(self, size):
            self.size = size
            self.id = [i for i in range(size)]
            self.component_size = [1 for i in range(size)]
        
        ## get the component id 
        def get_component_id(self,node_id):
            curr_id = node_id
            while (self.id[node_id] != node_id):
                node_id = self.id[node_id] 
            end = node_id
                
            ## flatten this structure (not necessary, just an optimization)
            curr_id = node_id
            while (self.id[node_id] != node_id):
                next_node = self.id[node_id] 
                self.id[node_id] = end
            return end
        
        ## are p and q in the same component?
        def is_connected(self,p,q):
            return self.get_component_id(p) == self.get_component_id(q)
        
        ## combined the two components p and q are in
        def join(self, p, q):
            root_p = self.get_component_id(p)
            root_q = self.get_component_id(q)
            
            if self.component_size[root_p] < self.component_size[root_q]:
                self.join(root_q,root_p)
                return
            
            if not self.is_connected(root_p,root_q):
            
                self.id[root_q] = root_p
                self.component_size[root_p] += self.component_size[root_q]
        
        ## what is the size of the component p is in?
        def get_size(self,p):
            return self.component_size[self.get_component_id(p)]
        
    
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        initial_set = set(initial)
        
        ## create connected components of non-malware nodes
        uf = Solution.UnionFind(n)
        for i in range(n):
            if i not in initial_set:
                for j in range(n):
                    if graph[i][j] and j not in initial_set:
                        uf.join(i,j)
        
        ## for each component, get a set of all malware nodes that connect directly to it
        components_to_malware = defaultdict(set)
        for i in initial_set:
            for j in range(n):
                if graph[i][j] == 1 and j not in initial_set:
                    components_to_malware[uf.get_component_id(j)].add(i)
        
        ## for each component if it is connected to:
        ##      0 malware nodes, then they will never be infected, no matter what is removed
        ##      1 malware node,  then they will not be infected if that node is removed, otherwise they will be
        ##      2 malware nodes, they will always be infected, no matter what is removed
        ## So go through every component, if it connected to only one malware node, add the components size
        ## to malware_size, which is a dictionary with keys the malware ids and values M(initial) if the id
        ## is removed.
        malware_size = defaultdict(int)
        for i in initial_set:
            malware_size[i] = 0
        for component in components_to_malware.keys():
            if len(components_to_malware[component]) == 1:
                for malware_id in components_to_malware[component]:
                    malware_size[malware_id] += uf.get_size(component)
        
        ## go through all malware_ids, select the id with greatest size (and smallest id if there is a tie)
        best_id = -1
        best_size = -1
        for malware_id in malware_size.keys():
            if malware_size[malware_id] > best_size or (malware_size[malware_id] == best_size and malware_id < best_id):
                best_size = malware_size[malware_id]
                best_id = malware_id
        return best_id