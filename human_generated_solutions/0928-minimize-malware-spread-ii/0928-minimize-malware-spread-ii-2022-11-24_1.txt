class Solution:
    # the key observation for me is the fact that we don\'t need to
    # really delete the initial in the graph. We can simply ignore
    # the deleted initial while we are doing BFS. So basically we
    # do BFS with each deleted value on initial, and we get the
    # minimal count of the connected graph. Note if two deleted
    # values give same count of connected graph, then we choose
    # smaller value. that\'s why I used a tuple, (BFS(a), a) this 
    # will first compare BFS(a), if they are equal then it compares
    # a.
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def BFS(delval):
            seen, lst = set(), list(initial)
            while lst:
                node = lst.pop()
                if node == delval or node in seen: continue
                seen.add(node)
                lst += [i for i, val in enumerate(graph[node]) if val]
            return len(seen)
        return min(initial, key=lambda a: (BFS(a), a))