class RandomizedCollection:

    def __init__(self):
        self.result = []
        # Additional memory - Map between value and SET of indices 
        self.element_to_indices = {}
        

    def insert(self, val: int) -> bool:
        val_idx = len(self.result)
        self.result.append(val)
        
        if val in self.element_to_indices:
            self.element_to_indices[val].add(val_idx)
            return False
        else:
            self.element_to_indices[val] = set([val_idx])
            return True

    # Objective here is to use array.pop() as its O(1)
    def remove(self, val: int) -> bool:
        
        if val not in self.element_to_indices:
            return False
        
        last_idx = len(self.result) - 1
        idx_to_pop = self.element_to_indices[val].pop()
            
        if not self.element_to_indices[val]:
            del self.element_to_indices[val]
            
        # Swapping val with element in last position 
        # And updating the indices SET accordingly
        if last_idx != idx_to_pop:
            last_ele = self.result[last_idx]
                
            # Indices are stored in SET O(1) add and remove here
            self.element_to_indices[last_ele].remove(last_idx)
            self.element_to_indices[last_ele].add(idx_to_pop)
                
            self.result[idx_to_pop], self.result[last_idx] = self.result[last_idx], self.result[idx_to_pop]
                
        self.result.pop()
        return True       

    def getRandom(self) -> int:
        return random.choice(self.result)