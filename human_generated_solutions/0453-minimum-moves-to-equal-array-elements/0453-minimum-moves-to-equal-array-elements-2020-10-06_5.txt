class Solution:
    def minMoves(self, nums: List[int]) -> int:
		# If we observe some sample arrays we will see that the minimum number has to equal the maximum number so that they are equal
		# However during this time (n - 2) elements will also increase by 1 for each step where n is the length of the array.
		# Example 1 :- [1, 2, 3]
		# For 1 to increase to 3 it will take exactly 2 steps but during these 2 steps 2 will also increase by 2 taking it to 4. Thus we would have to again take the two resulting 3s and make them into 4s in the next step.
		# Example 2:- [2, 2, 4]
		# 1st iteration : [3, 3, 4]
		# 2nd iteration : [4, 4, 4]
		# Let us now see the pattern. If we do abs(4 - 2 ) + abs (2 - 2) + abs (2 - 2) we get 2.
		# For [1, 2, 3] its abs(1 - 1) + abs(1 - 2) + abs(1 - 3) = 3
		# After the pattern is decoded, the implementation becomes simple.
		steps = 0
        min_num = min(nums)
        for num in nums:
            steps += abs(min_num - num)
        return steps