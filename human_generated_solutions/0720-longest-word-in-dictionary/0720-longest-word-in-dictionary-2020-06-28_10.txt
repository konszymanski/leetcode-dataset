class TrieNode {
public:
	unordered_map<char,shared_ptr<TrieNode>> children;
	bool end = false;
};

class Trie {
public:
	Trie () {
		root = make_shared<TrieNode>();
	}

	void insert(string word) {
		shared_ptr<TrieNode> cur = root;

		for (auto& c : word) {
			if (!cur->children.count(c))
				cur->children[c] = shared_ptr<TrieNode>(new TrieNode);

			cur = cur->children[c];
		}

		cur->end = true;
	}

	string helper(shared_ptr<TrieNode> node, string partial_res) {
		string res = partial_res;

		for (auto& i : node->children)
			if (i.second->end) {
				string res_ = helper(i.second, partial_res + i.first);

				if (res_.size() > res.size() || (res_.size() == res.size() && res_ < res))
					res = res_;
			}

		return res;
	}

	string longest_word() {
		return helper(root, "");
	}

private:
	shared_ptr<TrieNode> root;
};


//
class Solution {
public:
	string longestWord(vector<string>& words) {
		Trie T;

		for (auto& word : words)
			T.insert(word);

		return T.longest_word();
	}
};