class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        """
        This program uses dynamic programming to simulate the overflowing
        champagne tower, which enables the program to handle the query
        for the level of champagne in a glass at a particular location.
        The dynamic programming is accomplished within a single dimensional
        array.

        :param poured: total number of glasses of champagne
        :type poured: int
        :param query_row: row number with top row 0
        :type query_row: int
        :param query_glass: glass number within row with 1st glass 0
        :type query_glass: int
        :return: percent of glass filled at queried location
        :rtype: float
        """

        """
        Initialize the dynamic programming array (dp) to indicate
        the total amount of champagne that will flow into the single
        glass in the top row.
        """
        row = 0
        dp = [float( poured )]

        """
        Dynamic Programming:
        - Loop through the rows until the query row is reached.
        - Expand the dp to accommodate an additional glass whenever
          the row number is incremented.
        - At each row, simulate the overflow of champagne to the
          next row.
        - Be careful not to overwrite data until it is no longer
          needed.
        - Return the results of the query.
        """
        while row < query_row:
            row += 1
            dp = [0.0] + dp
            for k in range(1, row + 1):
                if dp[k] > 1.0:
                    dp[k - 1] += (dp[k] - 1.0) / 2.0
                    dp[k] = (dp[k] - 1.0) / 2.0
                else:
                    dp[k] = 0.0
        return min(1.0, dp[query_glass])