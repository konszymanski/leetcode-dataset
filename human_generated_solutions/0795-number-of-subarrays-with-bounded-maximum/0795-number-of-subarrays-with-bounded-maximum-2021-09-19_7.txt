class Solution:
    def numSubarrayBoundedMax(self, nums: [int], left: int, right: int) -> int:
        closestBounded = [-1] * len(nums)
        recentBounded = float(\'inf\')
        for i in range (len(closestBounded)-1, -1, -1):
            if left <= nums[i] <= right: 
                recentBounded = i 
            closestBounded[i] = recentBounded - i
        
        end = start = 0 
        ans = 0
        while end < len(nums): 
			# increment end pointer while valid
            while end < len(nums) and nums[end] <= right: 
                end += 1
            length = end - start
			# shrinking the window by incrementing start
            while start < end: 
				# adding subarrays [start:start+1], [start:start+2] ... [start:end]
                if left <= nums[start] <= right: 
                    ans += length
				# adding subararys but excluding invalid ones (i.e. the ones before most recent \'0\')
				# be careful though we should only be adding if closestBounded[start] < length
				# if not, this means the closest \'0\' is to the right of a \'1\' and it wouldn\'t make sense
				# to subtract it. We can just consider this case to be no closest \'0\' and not add anything
                elif closestBounded[start] != -1 and closestBounded[start] < length:
                    ans += (length - closestBounded[start])
                length -= 1
                start += 1
			# finding the next valid starting index
            while end < len(nums) and nums[end] > right: 
                end += 1
            start = end 
        return ans