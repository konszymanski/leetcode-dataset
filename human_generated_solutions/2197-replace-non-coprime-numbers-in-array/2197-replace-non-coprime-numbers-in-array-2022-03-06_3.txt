class DoublyLinkedNode:
    def __init__(self, val=0):
        self.val = val
        self.prev = None
        self.next = None

from math import gcd, lcm
class Solution:
    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:
        def connect(node1, node2):
            node1.next, node2.prev = node2, node1
        
        def are_deletable(node1, node2):
            return node1.val != 0 and node2.val != 0 and gcd(node1.val, node2.val) > 1
        
        #Create doubly linked list
        dummy_head, dummy_tail = DoublyLinkedNode(), DoublyLinkedNode()
        nodes = [DoublyLinkedNode(num) for num in nums]
        N = len(nodes)
        deletables = []
        for i in range(1, N):
            connect(nodes[i - 1], nodes[i])
            if are_deletable(nodes[i - 1], nodes[i]):
                deletables.append((nodes[i - 1], nodes[i]))
        connect(dummy_head, nodes[0]); connect(nodes[-1], dummy_tail);
        
        #connect adjacent nodes while deletables exist
        wasted = set()
        while deletables:
            node1, node2 = deletables.pop()
            if node1 in wasted or node2 in wasted:
                continue
            new_node = DoublyLinkedNode(val=lcm(node1.val, node2.val))
            connect(node1.prev, new_node); connect(new_node, node2.next);
            wasted.add(node1); wasted.add(node2);
            if are_deletable(new_node.prev, new_node):
                deletables.append((new_node.prev, new_node))
            if are_deletable(new_node, new_node.next):
                deletables.append((new_node, new_node.next)) 
        
		#output
        curr = dummy_head.next
        res = []
        while curr != dummy_tail:
            res.append(curr.val)
            curr = curr.next
        return res