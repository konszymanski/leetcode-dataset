class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        # Create a graph using python dict
        graph = defaultdict(list)
        
        # Trick #1: emails of each account together form a cycle in the graph, hence:
        # - uses less space than storing both u->v and v->u
        # - #nodes <= N*K, #edges = N*K
 \xA0 \xA0 \xA0 \xA0# - starts at any email (node), any other email of the same is visitable
 \xA0 \xA0 \xA0 \xA0# As the result, emails belong to a person create multiple cycles connected 
		# together making a connected component,
        # and the graph is consisted of many connected components like that.
        for acc in accounts:
            for i in range(1, len(acc) - 1):
                graph[acc[i]].append(acc[i+1])
            graph[acc[-1]].append(acc[1])
        
        # dfs to traverse all node in a connected component
        def __visit(node):
            # a node not in the graph means it has been visited
            if node not in graph:
                return []
            out = [node]
            # Trick #2: remove the node after visited, this saves some space 
			# because there\'s no need for storing the visited status of each node
            for child in graph.pop(node):
                out.extend(__visit(child))
            return out
        
        for acc in accounts:
            # an email is not in the graph means it has been visited and is belongs to a processed component
            if acc[1] in graph:
                # if an email is not visited, a new component is found
                yield [acc[0], *sorted(__visit(acc[1]))]
        
        # Time complexity is O(NKlogNK): O(NK) for building and traversing the graph, O(NKlogNK) for sorting.
        # Space complexity is O(NK): O(NK) for storing the graph and O(NK) for storing the output.