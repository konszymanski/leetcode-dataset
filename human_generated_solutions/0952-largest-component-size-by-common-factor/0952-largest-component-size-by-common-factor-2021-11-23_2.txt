class UnionFindSet(object):
    def __init__(self):
        self.data = collections.defaultdict(int)

    def find(self, x):
        while x <> self.data[x]:
            x = self.data[x]
        return x

    def union(self, x, y):
        if x not in self.data:
            self.data[x] = x
        if y not in self.data:
            self.data[y] = y
        self.data[self.find(x)] = self.find(y)

    def speedup(self):
        for x in self.data.keys():
            self.data[x] = self.find(x)


class Solution(object):
    def largestComponentSize(self, nums):
        # First of all, generate all prime numbers less than or equal to the max(nums) sequentially. 
        # It is true that this part of the code is intuitive and easy to understand, but its execution efficiency is not
        # high. I added a more efficient version in the comment area below, but it might not be that easy to understand.
        primes = []
        for num in range(2, max(nums) + 1):
            flag = True
            for prime in primes:
                if num % prime == 0:
                    flag = False
                    break
                if prime * prime > num:
                    break
            if flag:
                primes.append(num)

        # Secondly, find the smallest prime factor of each number.
        primes = set(primes)
        smallest_prime_factor = range(max(nums) + 1)
        for num in range(1, max(nums) + 1):
            if num in primes:
                continue
            for prime in primes:
                if num % prime == 0:
                    smallest_prime_factor[num] = prime
                    break

        # Thirdly, find all prime factors of each number, and generate a dictionary with prime factors as the key and
        # the list of numbers as the value.
        prime_factors = collections.defaultdict(list)
        for num in nums:
            n = num
            while smallest_prime_factor[n] < n:
                prime_factors[smallest_prime_factor[n]].append(num)
                n //= smallest_prime_factor[n]
            prime_factors[smallest_prime_factor[n]].append(num)

        # Fourthly, use UnionFindSet to connect numbers with common prime factors.
        uf = UnionFindSet()
        for nums in prime_factors.values():
            for i in range(1, len(nums)):
                uf.union(nums[i], nums[0])
        uf.speedup()

        # Finally, returns the number of elements in the largest subset.
        # Notice that if no edge could union, the UnionFindSet is empty.
        if len(uf.data) == 0:
            return 1
        return collections.Counter(uf.data.values()).most_common(1)[0][1]