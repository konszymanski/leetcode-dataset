class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        meetings.sort(key=lambda t: t[2])
        secret = {0, firstPerson}             # the initial secret group

        i = 0
        while i < len(meetings):
            end = meetings[i][2]
            mp = defaultdict(set)              # a map of meeting persons at the moment
            while i < len(meetings) and meetings[i][2] == end:
                a, b, _ = meetings[i]
                mp[a].add(b)
                mp[b].add(a)
                i += 1

            while mp:                          # people may meet in different groups at the moment
                seed = next(iter(mp))          # consider any remaining one as the first seed of a group
                seeds, group = {seed}, {seed}  # initiate the group which the seed belongs to
                while seeds:
                    meets = mp.pop(seeds.pop()) - group   # consider a seed and who else the seed meets
                    seeds |= meets                        # add new persons to the seed only!
                    group |= meets                        # add them into the group of course

                if group & secret:             # if anyone in this group knows the secret
                    secret |= group            # add the whole group into the secret group
                    if len(secret) == n:       # quick exit if possible
                        return list(secret)

        return list(secret)