class Solution:
    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
        #Base Cases
        know = [False for _ in range(n)]
        know[firstPerson] = True
        know[0] = True
        
        #Construct adjacency list per timestamp.
        peopleAtTimeStamp = defaultdict(set)
        adjList = defaultdict(lambda: defaultdict(list))
        
        for source, target, time in meetings:
            peopleAtTimeStamp[time].update({target, source})
            adjList[time][source].append(target)
            adjList[time][target].append(source)
            
        sortedTimes = sorted(set([meeting[2] for meeting in meetings]))
        
        #DFS for each unique time
        for time in sortedTimes:
            
            #Start the DFS only with people who know
            stack = [person for person in peopleAtTimeStamp[time] if know[person]]
            while stack:
                curr = stack.pop()
                for nei in adjList[time][curr]:
                    if not know[nei]:
                        stack.append(nei)
                        know[nei] = True
                
        return [index for index, value in enumerate(know) if value]