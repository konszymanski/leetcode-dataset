class Solution(object):
    def loudAndRich(self, richer, quiet):
        """
        :type richer: List[List[int]]
        :type quiet: List[int]
        :rtype: List[int]
        """
        
        def find_quietest(i):
            
            #recursively visit all the neighbors of i and calculate least noisy
            #sinc we have to apply min ops on the quiet[node_number]; we are storing both node_num and val of quiet[node_number]
            #for instance dict1 = {0: [1], 1: [2, 3], 3: [4, 5, 6], 7: [3]}
            #queit = [3,2,5,4,6,1,7,0]
            \'\'\'
            for node 0: we take min((0, 3), find_quietest(1)) --> min((0, 3), (5, 1)) --> (5,1)
            find_quietest(1) = min((1, 2), find_quietest(2), find_quietest(3))
                             = min((1, 2), (2, 5), (5, 1))
                             = (5, 1)
            find_quietest(2) = (2, 5)
            find_quietest(3) = min((3, 4), find_quietest(4), find_quietest(5), find_quietest(6)) 
                             = min((3,4), (4,6), (5,1), (6,7))
                             = (5,1)
            find_quietest(4) = (4, 6)
            find_quietest(5) = (5, 1)
            find_quietest(6) = (6, 7)
            
            \'\'\'
            
            if i in memo:
                return memo[i]
            
            #as no information has been given about i
            if i not in dict1:
                return (i, quiet[i])
            
            quietest = (i, quiet[i])
            
            for richer in dict1[i]:
                quietest = min(quietest, find_quietest(richer), key= lambda x: x[1])
            
            return quietest
        
        #base 
        if len(quiet) == 1:
            return quiet
        
        dict1 = {}
        memo = {}
        
        
        #Convert richer into a directed graph
        #For example: [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]]
        #dict[0] = [1] which indicates 1 has more money than 0
        #so value at key x is all people richer than x
        for val in richer:
            if val[1] in dict1:
                dict1[val[1]].append(val[0])
            else:
                dict1[val[1]] = [val[0]]
        
        
        #create a copy of quiet as every person will be either itself or least quiet between itself and all its richer neighbors  
        result = list(quiet)
        
        for i in range(len(quiet)):
            #navigate all the neighbors richer than the node
            output = find_quietest(i)
            result[i] = output[0]
            #used for memoization
            memo[i] = output
        
        return result