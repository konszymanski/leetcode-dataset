class Solution:
    def dfs(self, adj_list, ans, node, par):
        ans[node] = par
        
        for neig in adj_list[node]:
            if ans[neig] == -1:
                self.dfs(adj_list, ans, neig, par)
        
    
    def loudAndRich(self, richer: List[List[int]], quiet: List[int]) -> List[int]:
        order = [(quietness, idx) for idx, quietness in enumerate(quiet)]
        order.sort()
        n = len(quiet)
        
        # form adj list
        adj_list = collections.defaultdict(lambda: [])
        for par, child in richer:
            adj_list[par].append(child)
             
        ans = [-1]*n
        while order:
            _, node = order.pop(0)
            
            # update all possible child for the node using dfs
            # if not updated yet
            # no need of visited since there would be no cycles
            if ans[node] == -1:
                self.dfs(adj_list, ans, node, node)
                
        return ans