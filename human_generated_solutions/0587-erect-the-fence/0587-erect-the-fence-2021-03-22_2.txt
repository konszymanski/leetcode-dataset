class Solution(object):
    def outerTrees(self, points):
        #start with the leftmost point on the map
        leftmost = [float(\'inf\'), float(\'inf\')]
        for x,y in points:
            if x < leftmost[0]:
                leftmost = [x,y]
        #set this leftmost point as a starter
        current = leftmost
        
        res = set()
        res.add((leftmost[0],leftmost[1]))
        while True:
            target = points[0]
            linenodes = []
            for node in points:
                if node != current:
                    val = self.crossproduct(current,target,node)
                    if val > 0: #node is on the left of target
                        target = node 
                        linenodes = []
                    elif val == 0: #node is inline with the target
                        if ((node[0]-current[0])**2+((node[1]-current[1])**2)) < ((target[0]-current[0])**2+((target[1]-current[1])**2)):
                            linenodes.append(node) 
                        else:
                            linenodes.append(target)
                            target = node
                    else: #node is on the right of target, we don\'t care
                        continue 
            for linenode in linenodes:
                res.add((linenode[0],linenode[1]))
            if target == leftmost: #we encounter the start point, let\'s break 
                break
            res.add((target[0],target[1]))

            current = target
        return [[x,y] for x,y in res]
    
    def crossproduct(self,origin, target, node):
        x1 = origin[0] - target[0]
        y1 = origin[1] - target[1]
        x2 = origin[0] - node[0]
        y2 = origin[1] - node[1]
        return y2*x1 - y1*x2