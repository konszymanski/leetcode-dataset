import heapq
class MovieRentingSystem:

    def __init__(self, n: int, entries: List[List[int]]):
        self.movies = {}
        self.rented = set()
        for (shop, movie, price) in entries:
			# we store [price, shop, movie] as a list rather than a tuple because it enables mutable assignment in rent() and drop()
            self.movies.setdefault(movie, {}).setdefault(shop, [price, shop, movie])

    def search(self, movie: int) -> List[int]:
        return [shop for price,shop,_ in heapq.nsmallest(5, self.movies.get(movie, {}).values()) if price < 10001]

    def rent(self, shop: int, movie: int) -> None:
        self.rented.add((shop, movie))
        self.movies[movie][shop][0] += 10001
        
    def drop(self, shop: int, movie: int) -> None:
        self.rented.discard((shop, movie))
        self.movies[movie][shop][0] -= 10001

    def report(self) -> List[List[int]]:
        return heapq.nsmallest(5, self.rented, key=lambda sm: self.movies[sm[1]][sm[0]])