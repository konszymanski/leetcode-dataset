class Solution:
    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        res = 0
        m2 = [0] * n
        q = []
        
		# Build index map of nums2
        for i in range(n):
            m2[nums2[i]] = i
            
        for p1 in range(n):
            p2 = m2[nums1[p1]] # Position of nums1[p1] in nums2
            idx = bisect.bisect(q, p2) # Position smaller than this one so far
            q.insert(idx, p2)
            before = idx
            after = n-1 - p1 - p2 + before # Based on number of unique values before and after are the same
            res += before * after
            
        return res