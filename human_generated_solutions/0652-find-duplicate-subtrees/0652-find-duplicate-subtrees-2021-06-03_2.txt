# need to walk trees, preorder, inorder, postorder
# need to store unique subtrees somewhere Map/Set
# need unique key for subtree hash(key left + key right + val)
# handle hash conflicts?
# use hashmap to store monotonic id for (key left + key right + val)
# parent uses left child\'s mono id + right child\'s mono id + val

class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        subtrees = {}
        mono_id = 1
        visited = set()
        res = []
        def helper(node: TreeNode) -> int:
            nonlocal mono_id
            if not node:
                return 0
            left_id = helper(node.left)
            right_id = helper(node.right)
            key = (node.val, left_id, right_id)
            if key in subtrees:
                # already seen this unique subtree
                if key not in visited:
                    # first time re-visiting this unique subtree
                    visited.add(key)
                    res.append(node)
            else:
                # first time seeing this unique subtree
                subtrees[key] = mono_id
                mono_id += 1
            return subtrees[key]
        helper(root)
        return res