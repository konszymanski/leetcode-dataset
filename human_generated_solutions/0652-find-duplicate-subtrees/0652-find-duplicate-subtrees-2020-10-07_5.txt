# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        
        # KEEP TRACK OF {SUBTREE: [ROOT1, ROOT2, ...]} - {STR: [TREENODE, TREENODE, ...]}
        sub_roots_map = defaultdict(list)
        
        # START A PRE-ORDER TRAVERSAL TO FILL UP THE MAP
        self.preorder(root, sub_roots_map)
        
        # RETURN ANY ROOT FOR SUBTREES WITH MULTIPLE ROOTS
        return [root[0] for sub, root in sub_roots_map.items() if len(root) > 1]


    def preorder(self, root, sub_roots_map):
        if not root:
            return "null"
        
        # OBTAIN THE STRING REPRESENTATION OF THIS SUBTREE
        sub =f"{root.val},{self.preorder(root.left, sub_roots_map)},{self.preorder(root.right, sub_roots_map)}"
        
        # SAVE IT TO OUR MAP
        sub_roots_map[sub].append(root)
        
        # RETURN THE STRING REPRESENTATION OF THIS SUBTREE
        return sub