class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
    #---------------BFS-1-deque--Naive-------------------#
        from collections import deque
        wordDict = set(wordList)
        if endWord not in wordDict: return 0
        
        wordLen = len(beginWord)
        levels = {beginWord: 1}
        dq = deque([beginWord])
        
        while dq:
            currWord = dq.popleft()  
            currLevel = levels[currWord]
            for i in range(wordLen):
                c = currWord[i]
                for t in string.ascii_lowercase:
                    if c == t: continue
                    newWord = currWord[:i] + t + currWord[i + 1:]  #Try all 26 cases
                    if newWord == endWord:
                        return currLevel + 1
                    if newWord in wordDict:
                        wordDict.remove(newWord)
                        dq.append(newWord)
                        levels[newWord] = currLevel + 1
        return 0
    
    ---------------BFS-1-deque-Improved--Using--adjacent--list------------------#
        wordDict = set(wordList)
        if endWord not in wordDict: return 0
        wordLen = len(beginWord)
        
        adj = collections.defaultdict(list)
        for word in wordList:
            for i in range(wordLen):
                adj[word[:i] + \'*\' + word[i+1:]].append(word)
                
        dq = collections.deque([(beginWord, 1)])
        while dq:
            word, level = dq.popleft()
            for i in range(wordLen):
                dummyWord = word[:i] + \'*\' + word[i+1:]
                for newWord in adj[dummyWord]:
                    if newWord == endWord:
                        return level + 1
                    if newWord in wordDict:
                        wordDict.remove(newWord)
                        dq.append((newWord, level+1))
        return 0
    
    #---------------BFS-2-set---Naive------------------#
        wordDict = set(wordList)
        if endWord not in wordDict: return 0
        wordLen = len(beginWord)
        level = 1
        dq = {beginWord} 
        while dq:
            currWords = []
            for word in dq:
                currWords.append(word)
            newdp = set()
            for currWord in currWords:
                for i in range(wordLen):
                    c = currWord[i]
                    for t in string.ascii_lowercase:
                        if c == t: continue
                        newWord = currWord[:i] + t + currWord[i + 1:] #Try all 26 cases
                        if newWord == endWord:
                            return level + 1
                        if newWord in wordDict:
                            wordDict.remove(newWord)
                            newdp.add(newWord)
            level += 1
            dq = newdp
        return 0
    
    #---------------BFS-2-set--Improved-------------------#
        wordDict = set(wordList)
        if endWord not in wordDict: return 0
        wordLen = len(beginWord)
        level = 1
        dq = {beginWord} 
        
        adj = collections.defaultdict(list)
        for word in wordList:
            for i in range(wordLen):
                adj[word[:i] + \'*\' + word[i+1:]].append(word)
        while dq:
            currWords = []
            for word in dq:
                currWords.append(word)
            newdp = set()
            for currWord in currWords:
                for i in range(wordLen):
                    dummyWord = currWord[:i] + \'*\' + currWord[i+1:]
                    for newWord in adj[dummyWord]:
                        if newWord == endWord:
                            return level + 1
                        if newWord in wordDict:
                            wordDict.remove(newWord)
                            newdp.add(newWord)
            level += 1
            dq = newdp
        return 0

                        
    #--------------BidirectionBFS--------------#
        wordDict = set(wordList)
        if endWord not in wordDict: return 0
        wordLen = len(beginWord)
        level = 0
        forwards = {beginWord}
        backwards = {endWord}
        wordDict.remove(endWord)
        
        while backwards and forwards:
            level += 1
            if len(forwards) > len(backwards): forwards, backwards = backwards, forwards # a little trick here, always explore nodes in the smaller set
            newSet = set()
            for word in forwards:
                newWords = [ word[:i] + t + word[i+1:]  for t in string.ascii_lowercase for i in range(wordLen)]
                for newWord in newWords:
                    if newWord in backwards: return level + 1
                    if newWord not in wordDict: continue
                    wordDict.remove(newWord)                        
                    newSet.add(newWord)
            forwards = newSet
        return 0
    
     #--------------BidirectionBFS---Improved-----------#
        wordDict = set(wordList)
        if endWord not in wordDict: return 0
        wordLen = len(beginWord)
        level = 0
        forwards = {beginWord}
        backwards = {endWord}
        wordDict.remove(endWord)
        
        adj = collections.defaultdict(list)
        for word in wordList:
            for i in range(wordLen):
                adj[word[:i] + \'*\' + word[i+1:]].append(word)
        
        while backwards and forwards:
            level += 1
            if len(forwards) > len(backwards): forwards, backwards = backwards, forwards
            newSet = set()
            for currWord in forwards:
                newWords = []
                for i in range(wordLen):
                    for newWord in adj[currWord[:i] + \'*\' + currWord[i+1:]]:
                        newWords.append(newWord)
                for newWord in newWords:
                    if newWord in backwards: return level + 1
                    if newWord not in wordDict: continue
                    wordDict.remove(newWord)                        
                    newSet.add(newWord)
            forwards = newSet
        return 0