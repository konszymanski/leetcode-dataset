class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        equal = []
        non_equal = []
        
        # we divide the equations: equals - we store in a list of sets, and non-equals we store in a different list:
        for equation in equations: 
            if "==" in equation:
                # if "x==x", it is meaningless, so we can ignore it:
                if equation[0] != equation[3]: 
                    equal.append(set([equation[0], equation[-1]]))
            else:
                # if "x!=x" we can return False:
                if equation[0] == equation[-1]: 
                    return False
                non_equal.append(equation)
                
        # all equations are non-equal, and there is no "x!=x", so we can return True:
        if len(equal) == 0:
            return True
        
        sets = []
        sets.append(equal[0])

        # first round to unite sets with common values:
        for e in equal:
            for i in range(len(sets)):
                if len(sets[i] & e) > 0:
                    sets[i] = sets[i] | e
            else:
                sets.append(e)
                
        # one round is not enough, so we do a second round:
        united_sets =[]
        united_sets.append(sets[0])
        for s in sets:
            for i in range(0, len(united_sets)):
                if len(united_sets[i] & s) > 0:
                    united_sets[i] = united_sets[i] | s
            else:
                united_sets.append(s)
                
        # check if both sides of non-equal equation is in one set, then the result is False:
        for equation in non_equal:
            for equal in united_sets:
                if equation[0] in equal and equation[-1] in equal:
                    return False
        return True