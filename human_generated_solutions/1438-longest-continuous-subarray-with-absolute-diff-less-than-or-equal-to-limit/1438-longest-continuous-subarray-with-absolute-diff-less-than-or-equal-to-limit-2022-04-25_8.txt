class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        n = len(nums)
        i = j = maxlen = 0
        
        # minq is a monotonically increasing queue
        # maxq is a monotonically decreasing queue
        # both queue store indices of the values
        minq, maxq = deque(), deque()
        maxlen = 0
        while j < n:
            # preserve the monotonicity of the minq
            while minq and nums[minq[-1]] > nums[j]:
                minq.pop()
            # NOTE: check if the index we are pushing is not already pushed
            if not minq or minq[-1] != j:
                minq.append(j)
            
            # preserve the monotonicity of the maxq
            while maxq and nums[maxq[-1]] < nums[j]:
                maxq.pop()
            # NOTE: ensure we don\'t push duplicate indices
            if not maxq or maxq[-1] != j:
                maxq.append(j)
            
            # ensure minq and maxq don\'t have elements out of range of [i, j]
            if i > minq[0]:
                minq.popleft()
            if i > maxq[0]:
                maxq.popleft()
            
            # update maxlen and increment i and j
            minval = nums[minq[0]]
            maxval = nums[maxq[0]]
            if maxval - minval <= limit:
			    # if the window is valid we move j to right
                maxlen = max(maxlen, j - i + 1)
                j += 1
            else:
			    # otherwise we shrink the window by moving i to the right
                i += 1
        
        return maxlen