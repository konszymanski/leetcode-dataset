class SegmentTree:
    def __init__(self, arr, function):
        self.tree = [None for _ in range(len(arr))] + arr
        self.n = len(arr)
        self.fn = function
        self.build_tree()

    def build_tree(self):
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])
       
    def query(self, l, r):
        l += self.n
        r += self.n
        ans = 0
        while l < r:
            if l & 1:
                ans = self.fn(ans, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                ans = self.fn(ans, self.tree[r])
            l >>= 1
            r >>= 1
        return ans
    
    def update(self, i, val):
        i += self.n
        self.tree[i] += val
        while i > 1:
            i >>= 1
            self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1])
class Solution:
    # Classic Segment Tree Quesiton
    # The update function of the tree has to be changed
    # The root node of the tree will contain the result
    # For 1 length nums array as an edge case just check if the res node has even value or not cuz even + even is always even
    def sumEvenAfterQueries(self, nums: List[int], queries: List[List[int]]) -> List[int]:
        def dummy(x, y):
            if not x & 1 and not y & 1: return x + y
            elif not x & 1: return x
            elif not y & 1: return y
            else: return 0
        tree = SegmentTree(nums, dummy)
        res = []
        for val, i in queries:
            tree.update(i, val)
            res.append(tree.tree[1] if not tree.tree[1] & 1 else 0)
        return res