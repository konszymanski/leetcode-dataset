# # Recursive Solution for the Cherry Pick problem
# class Solution:
#     def cherryPickup(self, grid: List[List[int]]) -> int:
#
#         def helper(r1, c1, r2, c2, grid):
#             m = n = len(grid)
#             # invalid path
#             if r1 < 0 or r1 >= len(grid) or c1 < 0 or c1 >= len(grid[0]) or r2 < 0 or r2 >= len(grid) or c2 < 0 or c2 >= len(grid[0]) or grid[r1][c1] == -1 or grid[r2][c2] == -1:
#                 return float(\'-inf\')
#
#             # base condition
#             if r1 == m-1 and c1 == n-1:
#                 return grid[r1][c1]
#             if r2 == m-1 and c2 == n-1:
#                 return grid[r2][c2]
#             cherry = 0
#             if r1 == r2 and c1 == c2:
#                 cherry = grid[r1][c1] # if both the person at same place
#             else:
#                 cherry = grid[r1][c1] + grid[r2][c2] # if both at different place
#
#             # recursion
#
#             # both right
#             br = helper(r1, c1+1, r2, c2+1, grid)
#             # both down
#             bl = helper(r1+1, c1, r2+1, c2, grid)
#             # first right second down
#             frsd = helper(r1, c1+1, r2+1, c2, grid)
#             # first down second right
#             fdsr = helper(r1+1, c1, r2, c2+1, grid)
#
#             cherry += max(max(bl, fdsr), max(br, frsd))
#
#             return cherry
#
#         return helper(0, 0, 0, 0, grid) # r1, r2  c1, c2, grid
#
# s = Solution()
# print(s.cherryPickup([[0,1,-1],[1,0,-1],[1,1,1]]))

 # ===========================
 
# Memo Solution

# Since there are "4" parameters are changing so we have to have 4-D dp for storing the values

# 53 / 59 test cases passed.
# class Solution:
#     def cherryPickup(self, grid: List[List[int]]) -> int:
#         n = len(grid)
#         dp = [[[[-2] * n for i in range(n)] for j in range(n)] for k in range(n)]
#         def helper(r1, c1, r2, c2, grid):
#             m = n = len(grid)
#
#             # invalid path
#             if r1 < 0 or r1 >= len(grid) or c1 < 0 or c1 >= len(grid[0]) or r2 < 0 or r2 >= len(
#                     grid) or c2 < 0 or c2 >= len(grid[0]) or grid[r1][c1] == -1 or grid[r2][c2] == -1:
#                 return float(\'-inf\')
#
#             if dp[r1][c1][r2][c2] != -2:
#                 return dp[r1][c1][r2][c2]
#
#
#             # base condition
#             if r1 == m - 1 and c1 == n - 1:
#                 return grid[r1][c1]
#             if r2 == m - 1 and c2 == n - 1:
#                 return grid[r2][c2]
#             cherry = 0
#             if r1 == r2 and c1 == c2:
#                 cherry = grid[r1][c1]  # if both the person at same place
#             else:
#                 cherry = grid[r1][c1] + grid[r2][c2]  # if both at different place
#
#             # recursion
#
#             # both right
#             br = helper(r1, c1 + 1, r2, c2 + 1, grid)
#             # both down
#             bl = helper(r1 + 1, c1, r2 + 1, c2, grid)
#             # first right second down
#             frsd = helper(r1, c1 + 1, r2 + 1, c2, grid)
#             # first down second right
#             fdsr = helper(r1 + 1, c1, r2, c2 + 1, grid)
#
#             cherry += max(max(bl, fdsr), max(br, frsd))
#             dp[r1][c1][r2][c2] = cherry
#
#             return dp[r1][c1][r2][c2]
#
#         return max(0, helper(0, 0, 0, 0, grid))  # r1, r2  c1, c2, grid
#
#
# s = Solution()
# print(s.cherryPickup([[1,1,-1],[1,-1,1],[-1,1,1]]))

# ==========================================

# Space optimization in memo solution

# Obervation

# every time r1 + c1 == r2 + c2 So we can use 3D-Dp instead of using 4D-DP

# c2 = r1+c1-r2


# Accepted
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dp = [[[-2] * n for i in range(n)] for j in range(n)]
        def helper(r1, c1, r2, c2, grid):
            m = n = len(grid)
            c2 = r1 + c1 - r2

            # invalid path
            if r1 < 0 or r1 >= len(grid) or c1 < 0 or c1 >= len(grid[0]) or r2 < 0 or r2 >= len(
                    grid) or c2 < 0 or c2 >= len(grid[0]) or grid[r1][c1] == -1 or grid[r2][c2] == -1:
                return float(\'-inf\')

            if dp[r1][c1][r2] != -2:
                return dp[r1][c1][r2]


            # base condition
            if r1 == m - 1 and c1 == n - 1:
                return grid[r1][c1]
            if r2 == m - 1 and c2 == n - 1:
                return grid[r2][c2]
            cherry = 0
            if r1 == r2 and c1 == c2:
                cherry = grid[r1][c1]  # if both the person at same place
            else:
                cherry = grid[r1][c1] + grid[r2][c2]  # if both at different place

            # recursion

            # both right
            br = helper(r1, c1 + 1, r2, c2 + 1, grid)
            # both down
            bl = helper(r1 + 1, c1, r2 + 1, c2, grid)
            # first right second down
            frsd = helper(r1, c1 + 1, r2 + 1, c2, grid)
            # first down second right
            fdsr = helper(r1 + 1, c1, r2, c2 + 1, grid)

            cherry += max(max(bl, fdsr), max(br, frsd))
            dp[r1][c1][r2]= cherry

            return dp[r1][c1][r2]

        return max(0, helper(0, 0, 0, 0, grid))  # r1, r2  c1, c2, grid


s = Solution()
print(s.cherryPickup([[1,1,-1],[1,-1,1],[-1,1,1]]))