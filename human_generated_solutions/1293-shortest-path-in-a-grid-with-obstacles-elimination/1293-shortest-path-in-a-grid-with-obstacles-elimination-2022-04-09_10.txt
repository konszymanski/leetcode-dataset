from collections import deque
DIRECTIONS = [
    (-1, 0),
    (0, 1),
    (1, 0),
    (0, -1)
]
class Solution:
    def shortestPath(self, grid: List[List[int]], k: int) -> int:
        
        rows, cols = len(grid), len(grid[0])
        target = (rows - 1, cols - 1)
		
		# the case that we could always reach the target
        if k >= rows + cols - 2:
            return rows + cols - 2

        # (row, col, remaining quota to eliminate obstacles)
        state = (0, 0, k)
        # (state, steps)
        queue = deque([(state, 0)])
        visited = set([state])

        while queue:
            (row, col, k), steps = queue.popleft()

            if (row, col) == target:
                return steps

            for dx, dy in DIRECTIONS:
                new_row, new_col = row + dx, col + dy
                if not ((0 <= new_row < rows) and (0 <= new_col < cols)):
                    continue
                new_remaining_quota = k - grid[new_row][new_col]
                new_state = (new_row, new_col, new_remaining_quota)
                if new_remaining_quota >= 0 and new_state not in visited:
                    visited.add(new_state)
                    queue.append((new_state, steps + 1))

        return -1