def shortestPath(self, grid: List[List[int]], k: int) -> int:   

	trgtX, trgtY = len(grid)-1, len(grid[0])-1
	if trgtX == trgtY == 0:
		return 0

	if k > trgtX + trgtY: # as if no obstacles
		return trgtX + trgtY # unweighted grid -> shortest distance = all the way to the left + all the way to the right

	from collections import deque
	q = deque()
	q.append((0,0,0, k))
	visited = set()
	visited.add((0,0,k)) # same cell can be revisited via shorter path and less obstPass
	dirs = [(1,0), (0,1), (-1,0), (0,-1)]
	while q:
		x, y, r, obsPass = q.popleft()
		for dir in dirs:
			newX, newY = x+dir[0], y+dir[1]
			if newX >= 0 and newX <= trgtX and newY >= 0 and newY <= trgtY:   

				if (newX, newY) == (trgtX, trgtY): # trgt reached - each cell could either be 1 or 0 including trgt cell
							return r+1

				if grid[newX][newY] == 1: # obstacle
					if (newX, newY, obsPass-1) not in visited:
						if obsPass:
							q.append((newX, newY, r+1, obsPass-1))
							visited.add((newX, newY, obsPass-1))
				else:
					if (newX, newY, obsPass) not in visited:
						q.append((newX, newY, r+1, obsPass))
						visited.add((newX, newY, obsPass))
	return -1