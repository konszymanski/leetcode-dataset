class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        
        @cache
        def dp(i, left):
            if left == 0 or i >= N:
                return 0
            
            # Find the first event after event i that has starting time equal or greater than
            # the finish time of event i
            idx = bisect_right(events, events[i][1], key=lambda x: x[0])
            ans = max(
                dp(i + 1, left), # Don\'t attend current event
                dp(idx, left - 1) + events[i][2] # Attend current event
            )
            return ans
        
        N = len(events)
        events.sort()
        return dp(0, k)
    # Time: O(N * k * log(N)) where N is the length of events
    #       There are (N * k) dp states. Each dp state takes log(N) time
    # Space: O(N * k)