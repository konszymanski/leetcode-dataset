/*
    This problem can easily be solved using Depth First Traversal or Breadth First Traversal
    We will implement both to understand both the approaches thoroughly
    For either of the approaches, we will create two hash_maps, one to store the subordinates
    for an employee (essentially that are the neighbors)
    and other for storing the importance of the employee
    example: [[1, 3, [2,3,4]], [2, 2, []], [3, 5, [5,6]], [4, 8,[7,8,9]], [7,2,[]], [8,2,[]], [9,2,[]], [5, 3, []], [6, 5, []]]
    
    graph:
    1 | 2, 3, 4
    2 | []
    3 | [5, 6]
    4 | [7, 8, 9]
    5 | []
    6 | []
    7 | []
    8 | []
    9 | []
    
    importance map
    1 | 3
    2 | 2
    3 | 5
    4 | 8
    5 | 3
    6 | 5
    7 | 2
    8 | 2
    9 | 2
    
    DFS:
    start with the starting employee, add it\'s importance value
    traverse all it\'s subordinate and recursively call the same method again
    
    BFS:
    push the id into the queue
    while queue is not empty
    pop a node, add it\'s importance to ans
    traverse all it\'s neighbors and push them to queue
    return ans
    
    DFS approach was 63% faster, while BFS approach was 15% faster
*/