class Disset:
    def __init__(self, n):
        self.root = list(range(n + 1))
        self.rank = [0] * (n + 1)
        
    def find(self, x):
        if self.root[x] == x:
            return x
        self.root[x] = self.find(self.root[x])
        return self.root[x]
    
    def union(self, x, y):
        rootx = self.find(x)
        rooty = self.find(y)
        if rootx == rooty:
            return False
        if rootx != rooty:
            if self.rank[rootx] > self.rank[rooty]:
                self.root[rooty] = rootx
            elif self.rank[rootx] < self.rank[rooty]:
                self.root[rootx] = rooty
            else:
                self.root[rootx] = rooty
                self.rank[rooty] += 1
            return True
class Solution:
    # Points to remember - 
    # Joining from bottom up so that we are sure that lower vals can now not form any valid good paths
    # Updating the root with the counter of the bigger value because only the bigger value will be relevant going forward
    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:
        n, res = len(vals), len(vals)
        disset = Disset(n)
        edd = sorted([(max(vals[u], vals[v]), u, v) for u, v in edges])
        count = [Counter({vals[i]: 1}) for i in range(n)]
        for v, i, j in edd:
            rooti, rootj = disset.find(i), disset.find(j)
            ci, cj = count[rooti][v], count[rootj][v]
            res += ci * cj    # VIMP
            disset.root[rootj] = rooti
            count[rooti] = Counter({v: ci + cj})
        return res