class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        
        def transform(s):
            # return all possible transformed sequence from s
            res = []
            
            for i, c in enumerate(s):
                if c == \'R\' and i + 1 < len(s) and s[i+1] == \'X\':
                    # \'RX\' -> \'XR\'
                    res.append(s[:i] + \'XR\' + s[i+2:])
                
                if c == \'L\' and i - 1 >= 0 and s[i-1] == \'X\':
                    # \'XL\' -> \'LX\'
                    res.append(s[:i-1] + \'LX\' + s[i+1:])
                    
            return res
        
        
        if start == end:
            return True
        
        queue = [start]
        visited = set(queue[:])
        
        while queue:
            curr_s = queue.pop(0)
            if curr_s == end:
                return True
            
            for next_s in transform(curr_s):
                if next_s not in visited:
                    visited.add(next_s)
                    queue.append(next_s)
                    
        return False