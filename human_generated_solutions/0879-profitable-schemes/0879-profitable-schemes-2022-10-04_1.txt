class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -> int:
        # A[i][j][k] = # schemes using subset of first i crimes, using <= j people, with total profit >= k 
        A = [[[0 for k in range(minProfit + 1)] for j in range(n + 1)] for i in range(len(profit) + 1)]
        # if using first 0 crimes, only one way, and that if minProfit <= 0
        for j in range(n + 1):
            A[0][j][0] = 1
        for i in range(1, len(profit) + 1):
            for j in range(n + 1):
                for k in range(minProfit + 1):
                    # we are here calculating A[j][j][k]
                    # two cases, either we use i\'th crime or not. 
                    # but if i\'th crime requires more than j people, we con\'t use it
                    if group[i-1] > j:
                        A[i][j][k] = A[i-1][j][k]
                    else:
                        # if i\'th crime gets profit greater than k, then we have no restriction 
                        # on the rest of the groups
                        if profit[i-1] > k:
                            A[i][j][k] = (A[i-1][j][k] + A[i-1][j-group[i-1]][0]) % (10**9 + 7)
                        else:
                            A[i][j][k] = (A[i-1][j][k] + A[i-1][j-group[i-1]][k-profit[i-1]]) % (10**9 + 7)
        return A[len(profit)][n][minProfit]