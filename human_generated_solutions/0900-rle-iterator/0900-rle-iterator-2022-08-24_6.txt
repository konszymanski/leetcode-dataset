class RLEIterator:

    def __init__(self, encoding: List[int]):
        self.counts = [-1] # -1 to avoid indexing error 
        self.vals = []
        for i in range(len(encoding) // 2): 
            count, val = encoding[i*2], encoding[i*2+1] 
            if count > 0: 
                self.counts.append(count)
                if len(self.counts) > 1: 
                    self.counts[-1] += self.counts[-2] # build the prefix sum 
                self.vals.append(val)
        self.idx = -1 # an internal counter for handelling next calls 

	# I created my own bisect module here but in python it\'s built-in 
    def bi(self, idx): 
        if idx > self.counts[-1]: 
            return -1 
        l, r = 0, len(self.counts) - 1
        while l <= r: 
            mid = l + (r - l) // 2
            if self.counts[mid] < idx <= self.counts[mid+1]:
                return mid 
            if idx > self.counts[mid+1]: 
                l = mid + 1
            else: 
                r = mid - 1
        
    def next(self, n: int) -> int:
        self.idx += n 
        # i = self.bi(self.idx)
        i = bisect.bisect_left(self.counts, self.idx) - 1
        return self.vals[i] if i < len(self.vals) else -1