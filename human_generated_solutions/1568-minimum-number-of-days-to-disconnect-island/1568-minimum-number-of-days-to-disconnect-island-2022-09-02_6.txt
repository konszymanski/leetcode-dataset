class Solution:
    def minDays(self, grid: List[List[int]]) -> int:
        numRow, numCol = len(grid), len(grid[0])

        def numberOfIsland():
            directions = [[1,0],[-1,0],[0,1],[0,-1]]
            visited, ans, count = [[False]*numCol for _ in range(numRow)], 0, 0
            def dfs(i, j):
                nonlocal count
                visited[i][j] = True
                count += 1
                for dx, dy in directions:
                    nx, ny = i+dx, j+dy
                    if nx<0 or ny<0 or nx>=numRow or ny>=numCol or visited[nx][ny] or grid[nx][ny]==0: continue
                    dfs(nx, ny)
            for i in range(numRow):
                for j in range(numCol):
                    if grid[i][j] == 1 and visited[i][j] == False:
                        dfs(i, j)
                        ans += 1
            return ans, count

        num, countOf1 = numberOfIsland()
        if num != 1: return 0
        elif countOf1 == 1: return 1 #  num == 1
        elif countOf1 == 2: return 2 #  num == 1

        # build undirected graph
        def buildGraph():
            graph = {}
            directions = [[1,0],[-1,0],[0,1],[0,-1]]
            for i in range(numRow):
                for j in range(numCol):
                    if grid[i][j] == 1:
                        cur = i*numCol+j
                        graph[cur] = []
                        for dx, dy in directions:
                            nx, ny = i+dx, j+dy
                            if nx<0 or ny<0 or nx>=numRow or ny>=numCol or grid[nx][ny]==0: continue
                            neighbor = nx*numCol+ny
                            graph[cur].append(neighbor)
            return graph

        graph = buildGraph()
        def Tarjan(graph, root):
            # the graph has not isolated nodes or node groups
            hasCriticalEdge = False
            def dfs(previous, current, time, timeMap, visited):
                nonlocal hasCriticalEdge
                visited.add(current)
                timeMap[current] = time
                for nei in graph[current]:
                    if nei == previous: continue
                    if nei not in visited: dfs(current, nei, time+1, timeMap, visited)
                    if time < timeMap[nei]: hasCriticalEdge = True
                    timeMap[current] = min(timeMap[nei], timeMap[current])
            
            dfs(-1, root, 1, {}, set())
            return hasCriticalEdge
        hasCriticalEdge = Tarjan(graph, list(graph.keys())[0])

        return 1 if hasCriticalEdge else 2