class Solution:
    def minDays(self, grid) -> int:
        def find_cutting_points(graph):
            ids, low = {}, {}
            is_cut, id_max = set(), 0

            def dfs(u, p, root):
                nonlocal out_edge
                nonlocal id_max
                if p == root: 
                    out_edge += 1
                ids[u] = low[u] = id_max
                id_max += 1
                
                for v in graph[u]:
                    if v == p: continue
                    if v not in ids:
                        dfs(v, u, root)
                        low[u] = min(low[u], low[v])
                        if low[v] >= ids[u]:
                            is_cut.add(u)
                    else:
                        low[u] = min(low[u], ids[v])

            for u in graph.keys():
                if u not in ids:
                    out_edge = 0
                    dfs(u, -1, u)
                    if out_edge > 1:
                        is_cut.add(u)
                    else:
                        is_cut.remove(u)
            return is_cut

        uf = {}
        def find(x):
            uf.setdefault(x, x)
            if uf[x] != x: uf[x] = find(uf[x])
            return uf[x]
        def union(x, y): # x-> y
            uf[find(x)] = find(y)
            
        m, n = len(grid), len(grid[0])
        graph = defaultdict(set)
        for i in range(m):
            for j in range(n):
                if grid[i][j] != 1: continue
                find((i,j))
                for rr, cc in [(-1, 0), (0, -1)]:
                    r, c = i+rr, j+cc
                    if 0 <= r < m and 0 <= c < n and grid[r][c] == 1:
                        union((i, j), (r, c))
                        graph[(i,j)].add((r,c))
                        graph[(r,c)].add((i,j))

        if len(set(map(find, uf.keys()))) != 1:
            return 0
        if find_cutting_points(graph):
            return 1
        return 2