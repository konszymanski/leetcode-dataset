class Solution:
    def numFactoredBinaryTrees(self, A):
        
        ## dictionary
        # key: root node value
        # value: number of binary tree
        dp = defaultdict(int)
        
        
        # keep A sorted in ascending order
        A.sort()
        
        constant, size = (10**9 + 7), len(A)
        
        
        # scan each possible root node value
        for i, cur_num in enumerate(A):
            
            # Case 1: cur_num as root with child nodes
            
            # scan each potential child node value    
            for j in range(i):
                
                factor = A[j]
                quotient, remainder = divmod(cur_num, factor)
                
                # current (factor, quotient) pair are feasible to be child nodes 
                if remainder == 0:
                    dp[cur_num] += dp[quotient] * dp[factor]
            
            # Case 2: cur_num as root without child nodes
            dp[cur_num] += 1
            
        return sum( dp.values() ) % constant