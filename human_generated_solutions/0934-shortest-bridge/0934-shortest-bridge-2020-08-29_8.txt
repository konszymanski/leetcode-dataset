class Solution:
    def shortestBridge(self, A: List[List[int]]) -> int:
        def neighbors(x, y):
            for nx, ny in ((x+1, y), (x-1, y), (x, y+1), (x, y-1)):
                if 0 <= nx < R and 0 <= ny < C:
                    yield nx, ny
        R, C = len(A), len(A[0])
        for x, y in itertools.product(range(R), range(C)):
            if A[x][y]:
                break
        seen = set()            
        border = deque()
        def dfs(x, y):
            if not A[x][y] or (x, y) in seen:
                return
            seen.add((x, y))
            onBorder = False
            for nx, ny in neighbors(x, y):
                dfs(nx, ny)
                onBorder |= not A[nx][ny]
            if onBorder:
                border.append(((x, y), 0))
        dfs(x, y)        
        while border:
            (x, y), d = border.popleft()
            for nx, ny in neighbors(x, y):
                if (nx, ny) not in seen:
                    if A[nx][ny]:
                        return d
                    border.append(((nx, ny), d+1))
                    seen.add((nx, ny))