class Solution:
    def minFlips(self, mat: List[List[int]]) -> int:
        row_count, col_count = len(mat), len(mat[0])
        
        # 2d list -> 2d tuple
        def matrix_to_state(matrix):
            return tuple([tuple(row) for row in matrix])
        
        # 2d tuple -> 2d list
        def state_to_matrix(state):
            return [list(row) for row in state]
        
        # state -> state
        def flip(state, ri, ci):
            matrix = state_to_matrix(state)
            for tmp_ri, tmp_ci in [(ri, ci), (ri+1, ci), (ri-1, ci), (ri, ci+1), (ri, ci-1)]:
                if (0 <= tmp_ri < row_count) and (0 <= tmp_ci < col_count):
                    matrix[tmp_ri][tmp_ci] = 1 - matrix[tmp_ri][tmp_ci]
            return matrix_to_state(matrix)
    
        # state -> bool
        def is_goal_state(state):
            return all([cell == 0 for row in state for cell in row])
        
        # BFS
        q = [(matrix_to_state(mat), 0)]
        visited_states = set()
        for state, steps in q:
            if is_goal_state(state):
                return steps
            
            if state in visited_states:
                continue
            visited_states.add(state)
            
            # try flip each cell
            for flip_ri in range(row_count):
                for flip_ci in range(col_count):
                    next_state = flip(state, flip_ri, flip_ci)
                    q.append((next_state, steps + 1))
            
        return -1