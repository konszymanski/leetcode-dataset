class Solution:
    def minFlips(self, mat: List[List[int]]) -> int:
        \'\'\'
        Flatten the matrix into a string, so we can use it as a state, then
        use BFS to find the target which would be \'0000..000\' depending on the size of the matrix.
        
        Nothing special. This problem is similar to 773. Sliding Puzzle.
        \'\'\'
        rows, cols = len(mat), len(mat[0])
        initial = \'\'.join(str(cell) for row in mat for cell in row)
        target = \'0\' * (rows * cols)
        \'\'\'bfs\'\'\'
        flips = { \'1\': \'0\', \'0\': \'1\' }
        def flip(node, pos):
            node[pos] = flips[node[pos]]
            if pos % cols != 0:
                left = pos - 1
                node[left] = flips[node[left]]
            if pos % cols < cols - 1:
                right = pos + 1
                node[right] = flips[node[right]]
            if pos >= cols:
                top = pos - cols
                node[top] = flips[node[top]]
            if pos < (rows - 1) * cols:
                bottom = pos + cols
                node[bottom] = flips[node[bottom]]
        
        q = collections.deque([initial])
        steps = 0
        visited = set()
        while q:
            for _ in range(len(q)):
                node = q.popleft()
                if node == target:
                    return steps
                if node in visited:
                    continue
                visited.add(node)
                for i in range(len(node)):
                    nextNode = list(node)
                    flip(nextNode, i)
                    q.append(\'\'.join(nextNode))
            steps += 1

        return -1