class Solution:
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        jobs = list(zip(startTime, endTime, profit))
        
        # sort by end time
        jobs.sort(key = lambda x: (x[1]))
        
        n = len(jobs)
        
        dp = [0] * (n)
        prev = [-1] * (n)
        
        # calculate the first job can be picked up before ith job
        for i in range(1, n):
            for j in reversed(range(i)):
                if jobs[j][1] <= jobs[i][0]:
                    prev[i] = j
                    break
        
        # init
        dp[0] = jobs[0][2]
        for i in range(1, n):
            # if there is no job to be picked up, we can only continue to have the previous Max or pick the ith job
            if prev[i] == \'-1\':
                dp[i] = max(dp[i-1], jobs[i][2])
            else:
                # we can pick i-th job, plus the previous Max
                # or we do not pick up the i-th job
                dp[i] = max(jobs[i][2] + dp[prev[i]], dp[i-1]);
        return dp[-1]