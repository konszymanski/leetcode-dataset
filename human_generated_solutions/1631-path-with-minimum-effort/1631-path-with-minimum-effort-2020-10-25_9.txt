class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        if len(heights) < 2 and len(heights[0]) < 2: return 0 # This line of code prevents me from AC..
		
		# Union Find
        graph = [i for i in range(len(heights) * len(heights[0]))]
        size = [1 for i in range(len(heights) * len(heights[0]))]
        
        def find(a):
            n = 0
            while graph[a] != a:
                graph[a] = graph[graph[a]]
                a = graph[a]
                n += 1
            return a
        
        def union(a, b):
            a, b = find(a), find(b)
            if a == b: return
            if size[a] < size[b]:
                graph[a] = b
                size[b] += size[a]
            else:
                graph[b] = a
                size[a] += size[b]
                
        # Put every path into a list and sort with effort. Structure: (from, to, effort)
        m, n = len(heights), len(heights[0])
        paths = []
        for i in range(1, m): paths.append(((i-1) * n, i * n, abs(heights[i][0] - heights[i-1][0])))
        for i in range(1, n): paths.append((i-1, i, abs(heights[0][i] - heights[0][i-1])))
        for i in range(1, m):
            for j in range(1, n):
                paths.append(((i-1) * n + j, i * n + j, abs(heights[i][j] - heights[i-1][j])))
                paths.append((i * n + j - 1, i * n + j, abs(heights[i][j] - heights[i][j-1])))
        paths = sorted(paths, key=lambda x : x[2])
        
		# Run union find by put the sorted path into union one by one
        ptr = 0
        while find(0) != find(m * n - 1):
            union(paths[ptr][0], paths[ptr][1])
            ptr += 1
            
        return paths[0 if ptr == 0 else ptr - 1][2]