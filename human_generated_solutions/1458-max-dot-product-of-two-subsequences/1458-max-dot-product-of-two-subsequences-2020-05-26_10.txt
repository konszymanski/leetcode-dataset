class Solution:
    def maxDotProduct(self, nums1, nums2) -> int:
        """
        This program uses dynamic programming in a top down manner to
        determine the maximum dot product of a subset of nums and a
        subset of nums2.

        :param nums1: first array of integers
        :type nums1: list[int]
        :param nums2: second array of integers
        :type nums2: list[int]
        :return: maximum dot product from nums1 and nums2
        :rtype: int
        """
        """
        Initialize:
        - Pad the arrays to enable smooth handling of the edge cases and
          clean indexing.
        - Initialize the dp matrix to values that are guaranteed to be less
          than the minimum value of a maximum dot product.
        """
        nums1 = [-1000] + nums1
        nums2 = [-1000] + nums2
        len_nums1 = len(nums1)
        len_nums2 = len(nums2)
        dp = [([-10**7] * len_nums2) for _ in range(len_nums1)]

        """
        Dynamic Programming:
        - The matrix of interest starts at row 1, column 1. The 0th row
          and 0th column exist for padding purposes and are derived from
          the padding of the arrays.
        - Compute each entry in the dp matrix such that it contains the
          maximum dot product for a submatrix whose upper left corner is
          at row 1, column 1 and whose lower right corner is at the location
          of the dp entry.
        - Return the final result from the lower right corner of the entire
          dp matrix.
        """
        for k1 in range(1, len_nums1):
            for k2 in range(1, len_nums2):
                dp[k1][k2] = nums1[k1] * nums2[k2] + max(0, dp[k1 - 1][k2 - 1])
                dp[k1][k2] = max([dp[k1][k2], dp[k1 - 1][k2], dp[k1][k2 - 1]])
        return dp[-1][-1]