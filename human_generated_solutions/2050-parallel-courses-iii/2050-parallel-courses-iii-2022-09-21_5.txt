class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        # key is the course, and value is a list of all the prerequiste courses for this current course 
        indegree = defaultdict(list)
        # key is the course, and the value is other courses that needs the key as prerequiste 
        outdegree = defaultdict(list)
        # tracks the min time needed to finish the current course (time[course] + time[prerequisite]) 
        accumulative_time = defaultdict(int)
        
        # build the indegree and outdegree dicts 
        for u, v in relations: 
            indegree[v].append(u)
            outdegree[u].append(v)
  
        queue = []
        # add all the courses that do not need any prerequisite to the queue 
        for i in range(1, n+1):
            if i not in indegree:
                queue.append(i)  

        while queue:
            node = queue.pop(0)
            #  add prerequisite time to the current course 
            accumulative_time[node] += time[node-1]
            # process the neighbor 
            for neighbor in outdegree[node]:
                accumulative_time[neighbor] = max(accumulative_time[neighbor], accumulative_time[node])
                # remove the node after it\'sprocessed 
                indegree[neighbor].remove(node)
                # process the neighbor if it doesn\'t have any prerequisite
                if indegree[neighbor] == []:
                    queue.append(neighbor) 
                   
        all_values = accumulative_time.values()
        # the returned value is the max in all the values in the time dict 
        total = max(all_values)
        return total