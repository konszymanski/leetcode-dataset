def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        # n+1 due to input node starting at 1 instead of 0
        # initialize map where every node is indegree of 0.
				in_degree=dict.fromkeys(range(1, n+1, 1), 0)
        #print("indegree initial", in_degree)
        graph=defaultdict(list)
                
        for src, dest in relations:
            graph[src].append(dest)
            in_degree[dest] = in_degree.get(dest,0) + 1
        #print(graph)
        #print("in_degree", in_degree)
        
        q = deque([k for k in range(1, n+1, 1) if in_degree[k] == 0])
        #print("q", q)
        dist=dict.fromkeys(range(1, n, 1), 0)
        n = 1
        for cost in time:
            dist[n] = cost
            n += 1
        #print("dist", dist)

        while q:
            node = q.popleft()
            #print(node)
            for nei in graph[node]:
                # Update `dist[nei]` using the maximum dist 
                # of the predecessor nodes
                # print("nei", nei)
                # print("dist[nei]", dist[nei])
                # print("time[nei]", time[nei-1])
                dist[nei] = max(dist[nei], time[nei-1] + dist[node])
                # print("dist after update", dist)
                in_degree[nei] -= 1
                if in_degree[nei] == 0:
                    q.append(nei)
        
        # LC guaranteed a DAG so we always have a topological sort
			  # so don\'t need to validate for this problem.
        return max(dist.values())