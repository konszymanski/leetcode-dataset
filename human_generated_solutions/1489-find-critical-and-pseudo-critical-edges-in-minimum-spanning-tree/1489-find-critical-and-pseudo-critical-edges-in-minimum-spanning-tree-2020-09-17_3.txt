class DSU:
    def __init__(self, N: int):
        # initially, every node forms a partition of size 1
        self.par = list(range(N))   #             the partition to which every node belongs
        self.sz = [1] * N           # the size of ...
    
    def find(self, x: int) -> int:
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]
    
    def union(self, x: int, y: int) -> bool:
        xr, yr = self.find(x), self.find(y)
        if xr == yr:
            return False
        if self.sz[xr] < self.sz[yr]:
            xr, yr = yr, xr
        self.par[yr] = xr
        self.sz[xr] += self.sz[yr]
        self.sz[yr] = self.sz[xr]
        return True
    
    def size(self, x: int) -> int:
        return self.sz[self.find(x)]


class Solution:
    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        edges = sorted((w, u, v, i) for i, (u, v, w) in enumerate(edges))
        critical, pseudo = [], []
        for _w, _u, _v, i in edges:
            dsu1, dsu2 = DSU(n), DSU(n)
            dsu1.union(_u, _v)
            s1, s2 = _w, 0
            for w, u, v, j in edges:
                if i == j:
                    continue
                if dsu1.union(u, v):
                    s1 += w
                if dsu2.union(u, v):
                    s2 += w
            if s1 == s2:
                pseudo.append(i)
            elif s1 < s2 or dsu2.union(_u, _v):
                critical.append(i)
        return critical, pseudo