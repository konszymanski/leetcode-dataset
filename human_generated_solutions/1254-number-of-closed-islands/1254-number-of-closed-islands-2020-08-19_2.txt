class Solution(object):
    def closedIsland(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        count =0
        
        # iterate through the grid from 1 to length og grid for rows
        # and columns.
        # the iteration starts from 1 because if a 0 is present
        # in the 0th column, it can\'t be a closed island.
        for i in range(1, len(grid)-1):
            for j in range(1, len(grid[0])-1):
                
                # if the item in the grid is 0 and it is surrounded by
                # up, down, left, right 1\'s then increment the count.
                if grid[i][j] == 0 and self.dfs(grid, i , j):
                    count +=1
        return count
    
    def dfs(self, grid, i, j):
        
        # if grid[i][j] is 1 then return True, this helps is checking the
        # final return conditons.
        if grid[i][j]==1:
            return True
        
        # now check if the element 0 is present at the outmost rows and column
        # then return False
        if i<=0 or j<=0 or i>=len(grid)-1 or j >=len(grid[0])-1:
            return False
        
        # initialize the item as 1
        grid[i][j] = 1
        
        # now check the conditions for up, down, left, right
        up = self.dfs(grid, i+1, j)
        down = self.dfs(grid, i-1, j)
        right = self.dfs(grid, i, j+1)
        left = self.dfs(grid, i, j-1)
        
        # if up, down , left, right is True, then return to main function
        return up and down and left and right