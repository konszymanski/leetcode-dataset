class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        arr=[0]*((n*2)-1)
        self.ans=None
        def dfs(arr,i):
            for num in range(n,0,-1):#Traverse Reverse as we need highest lexicographic number
                if num not in arr:
                    if num==1:
                        if arr[i]!=0:#place is occupied
                            continue
                        else:#Occupy the one place
                            arr[i]=1
                    else:
                        if arr[i]!=0 or (i+num)>=len(arr) or arr[i+num]!=0:#place is occupied or invalid
                            continue
                        else:#Occupy the two place
                            arr[i]=num
                            arr[i+num]=num
                    if 0 in arr:#means few places are still vacant
                        if dfs(arr,arr.index(0)):
                            return True
                        if arr[i]==1:#Backtracking vacate the one place
                            arr[i]=0
                        else:#Backtracking vacate both the two occupied place
                            arr[i]=0
                            arr[i+num]=0
                    else:#Yay no place is vacant 
                        self.ans=arr
                        return True
                    
        dfs(arr,0)
        return self.ans