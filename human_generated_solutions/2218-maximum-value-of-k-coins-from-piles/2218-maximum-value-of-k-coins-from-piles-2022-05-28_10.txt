from functools import cache
from typing import List


class Solution:
    def maxValueOfCoins(self, piles: List[List[int]], K: int) -> int:
        """
        :param piles:
        :param K:
        :return:
        """
        return self.bottom_up(piles, K)
        # return self.top_down(piles, K)

    @staticmethod
    def bottom_up(piles: List[List[int]], K: int) -> int:
        @cache
        def dp(i: int, k: int) -> int:
            """
            :param i:
            :param k:
            :return: best total value by picking k coins from piles[:i]
            """
            if (
                    k == 0  # no coins to pick
                    or
                    i == 0  # no piles to pick coin from 
            ):
                return 0

            output = dp(i - 1, k)  # no coin selected from ith pile
            pile, cum_sum = piles[i - 1], 0

            for j in range(min(len(pile), k)):
                cum_sum += pile[j]

                output = max(
                    output,  # not picking (j + 1) top coins from ith pile
                    dp(i - 1, k - j - 1) + cum_sum  # picking (j + 1) top coins from ith pile and rest from piles[:i-1]
                )

            return output

        return dp(len(piles), K)

    @staticmethod
    def top_down(piles: List[List[int]], K: int) -> int:
        """
        @see https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/discuss/1887010/JavaC%2B%2BPython-Top-down-DP-solution
        :param piles:
        :param K:
        :return:
        """
        n = len(piles)

        @cache
        def dp(i: int, k: int) -> int:
            """
            :param i:
            :param k:
            :return: best total value by picking k coins from piles[i:]
            """
            if (
                    k == 0  # no coined need to be picked
                    or
                    i == n  # no piles in piles[n:]
            ):
                return 0

            output = dp(i + 1, k)  # no coin selected from ith pile
            pile, cum_sum = piles[i], 0

            for j in range(min(len(pile), k)):
                cum_sum += pile[j]

                output = max(
                    output,  # not taking top (j + 1) top coins from ith pile
                    dp(i + 1, k - j - 1) + cum_sum  # taking (j + 1) coins from ith pile and rest from piles[i + 1:]
                )

            return output

        return dp(0, K)