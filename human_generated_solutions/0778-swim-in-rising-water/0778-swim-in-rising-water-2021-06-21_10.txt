class Solution:
    def swimInWater(self, grid) -> int:
        """
        Given an NxN grid whose elements are a permutation of
        the array [0, 1, ..., NxN - 1], this program determines
        the least time needed to reach the bottom right cell
        from the top left cell. It uses binary search combined
        with depth-first search (dfs) to determine the answer.

        :param grid: square matrix where each cell represents
                     an elevation
        :type grid: list[list[int]]
        :return: least time needed to reach bottom right cell
                 from the top left cell.
        :rtype: int
        """

        def dfs(row: int, col: int, swim_time: int, visited) -> bool:
            """
            Given the row and column location of a cell (row, col),
            a candidate swim time (swim_time), and the set of
            cells already visited (visited), this program uses
            depth-first search recursively to determine whether
            it is possible to reach the bottom right cell of
            the grid within swim_time.
            
            :param row: cell row
            :type row: int
            :param col: cell column
            :type col: int
            :param swim_time: candidate swim time
            :type swim_time: int
            :param visited: set of cells already visited with
                            each cell represented as (row, col)
                            tuple
            :type visited: set(tuple)
            :return: True if it is possible to reach the bottom
                     right cell (grid[-1][-1] within swim_time,
                     else False
            :rtype: bool
            """
            
            """
            Return False when:
            - given location defined by row and col is off the grid
            - given location has already been visited
            - the cell time (cell_time) is greater than swim_time
            """
            if row < 0 or row >= len_grid or col < 0 or col >= len_grid:
                return False
            if (row, col) in visited:
                return False
            visited.add((row, col))
            cell_time = grid[row][col]
            if cell_time > swim_time:
                return False
            
            """
            Return True if the given location is the bottom
            right cell of the grid.
            """
            if row == len_grid - 1 and col == len_grid - 1:
                return True
            
            """
            Perform depth-first search (dfs) on all adjacent cells.
            """
            if dfs(row + 1, col, swim_time, visited):
                return True
            elif dfs( row, col + 1, swim_time, visited ):
                return True
            elif dfs( row - 1, col, swim_time, visited ):
                return True
            elif dfs(row, col - 1, swim_time, visited):
                return True
            return False

        """
        Use binary search and dfs to find the lowest swim time
        that enables a swimmer to reach grid[-1][-1] from
        grid[0][0].
        """
        len_grid = len(grid)
        left = grid[-1][-1]
        right = len_grid * len_grid - 1
        while left < right:
            visited = set()
            swim_time = left + (right - left) // 2
            if dfs(0, 0, swim_time, visited):
                right = swim_time
            else:
                left = swim_time + 1
        return left