class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        n = len(grid)
        def getNeighbours(i, j):
            positions = [[-1,-1], [-1,0], [-1,1],[0,-1], [0,1], [1, -1], [1, 0], [1, 1]]            
            for pos in positions:
                i1, j1 = i + pos[0], j + pos[1]                
                if i1 >= 0 and i1 < n and j1 >= 0 and j1 < n and grid[i1][j1] == 0:
                    yield (i1, j1)
                    
        solution = [[999999] * n for _ in range(n)]
        solution[0][0] = 1
        if grid[0][0] != 0 or grid[n-1][n-1] != 0:
            return -1
        
        h = []
        heapq.heappush(h, (1, (0, 0, 1)))
        while h:
            est, (i, j, sp) = heapq.heappop(h)            
            solution[i][j] = sp
            if i == n - 1 and j == n - 1:
                break
            for i1, j1 in getNeighbours(i, j):
                if solution[i1][j1] > sp + 1:
                    heapq.heappush(h, (sp + 1 + max(n - i1 - 1, n - j1 - 1), (i1, j1, sp + 1)))
                    solution[i1][j1] = solution[i][j] + 1
        
        if solution[n-1][n-1] == 999999:
            return -1
        else:
            return solution[n-1][n-1]