def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
        #Time->O(nlogn), Space->O(1)
        # arr.sort()
        # arr[0] = 1
        # for i in range(1, len(arr)):
        #     if (arr[i] - arr[i-1]) > 1:
        #         arr[i] = arr[i-1] + 1
        # return arr[-1]
    
        #Time->O(n), Space->O(n)
        #the perfect sequence is [len(arr),len(arr)-1,.....1], notice ans = len(arr)
        #start from len(arr) and go down to 1 as i
        #if count(i) > 1, those "extra values" can be reduced to give us a perfect sequence
        #any values in arr that are greater than len(arr) will also act as "extra values" to help in making perfect sequence
        #BUT what if we count(i) = 0 and we dont have "extra values" available?
        #then we must pop the last element of our perfect sequence to get that "extra value", notice ans = len(arr) - 1
        ans = i = len(arr)
        count = Counter(arr)
        extraValues = sum([val > ans for val in arr])
        for i in range(i, 0, -1):
            if count[i]:
                extraValues += count[i] - 1
            elif extraValues:
                extraValues -= 1
            else:
                ans -= 1