class Solution { // BFS: BEST; Time/Space: O(n^(K+1)), O(n^(K+1))
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {
        int ans = INT_MAX;
        unordered_map<int, vector<pair<int, int>> > schedules;
        for(auto flight: flights)            
            schedules[flight[0]].emplace_back(flight[1], flight[2]); //okay
            //schedules[flight[0]].push_back({flight[1], flight[2]}); //Note1             
        queue<pair<int, int>> q{{{src, 0}}}; // it costs 0 to reach \'src\'
        for(int step = 0; !q.empty() && step <= K+1; step++){
            for(int size = q.size(); size-->0;){
                auto [target, cost] = q.front();q.pop();   //step1: current node                
                if(target == dst) {
                    ans = min(ans, cost);
                    continue; //Note4:
                }
                for(auto& next: schedules[target]){   //step2: check next nodes
                    if(cost + next.second > ans ) continue; //Note2: pruning
                    if(step == K + 1 && next.first != dst) continue; //Note5
                    q.emplace(next.first, cost + next.second); //Note3                    
                }
            }
        }
        return ans==INT_MAX? -1: ans;                             
    }          
};
/*
Note1: key->value means: src->{dst, cost}
Note2: pruning by best cost by far
Note3: why not need marking visited? Checking City 2 in Example 1. You may revist same city in different steps
Note4: Optional. If we reach destination, we don\'t need to process target\'s neighbor
Note5: Optional. If this is the last iteration, we should only update neighbor == target; otherwise we might create other minCost that require more than k stops
*/