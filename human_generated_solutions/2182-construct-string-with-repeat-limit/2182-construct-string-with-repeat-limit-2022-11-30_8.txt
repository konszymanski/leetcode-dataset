class Solution:
    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
        alphabetOccurences = [0] * 26
        for char in s:
            alphabetOccurences[ord(char) - ord(\'a\')] += 1

        result = []
        count = len(s)
        currentCharIndex = 26

        def getLargestCharacterIndexNotEqualCurrentCharIndex(currentCharIndex):
            totallyBestIndex = 0
            for index in range(25, -1, -1):
                if alphabetOccurences[index] > 0:
                    totallyBestIndex = max(totallyBestIndex, index)
                    if index != currentCharIndex:
                        return index, totallyBestIndex
            return -1, totallyBestIndex

        def getCharByIndex(index):
            return chr(ord(\'a\') + index)
    
        while count:
            # Obtain the index of lexicographically larger character greedily and the available character count
            bestCharIndex, totallyBestIndex = getLargestCharacterIndexNotEqualCurrentCharIndex(currentCharIndex)
            if bestCharIndex == -1: break

            charCount = alphabetOccurences[bestCharIndex]

            # Compute the character count to be reduced based on the remaining count
            characterCountReduced = 1 if bestCharIndex < totallyBestIndex else min(charCount, repeatLimit)

            # Append the characters reduced and remove it from alphabet occurences and count variable
            result.append(getCharByIndex(bestCharIndex) * characterCountReduced)

            alphabetOccurences[bestCharIndex] -= characterCountReduced
            count -= characterCountReduced

            # Update current char index
            currentCharIndex = bestCharIndex

        # Join the result array to string
        # Time: O(n)
        # Space: O(1)
        return \'\'.join(result)

        # Experiment
        # Idea: store the counter of each character in ascending order then greedily take the largest alphabet
        # ==========
        # z: 2
        # c: 4
        # a: 1
        # repeatLimit = 3
        # currentindex = 26 (not possible)
        
        # strategy: be greedy
        # check the largest element that doesnt equal current 

        # append both z and reduce it by 3

        # c: 4
        # a: 1
        # currentindex = 25 -> z
        # result = zz

        # -> c (4) > 3
        # append c * 3 and reduce it by 3
        # c: 1
        # a: 1
        # currentindex = 2 -> c
        # result = zzccc

        # -> a (1) < 3
        # append a * 1 and reduce it by 3
        # c: 1
        # currentindex = 0 -> a
        # result = zzccca